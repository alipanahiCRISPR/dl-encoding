# -*- coding: utf-8 -*-
"""offtargetsexp.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1HiIIamPDUmqsEQnpVWEJXCPp1AQ_4lgL
"""

# -*- coding: utf-8 -*-
"""Perform the Experiments for Off-Target Predictions.
===============================================
Version |    Date     |   Author    |   Comment
-----------------------------------------------
0.0     | 25 Oct 2020 | J. Charlier | initial version
0.1     | 09 Nov 2020 | J. Charlier | update new version
0.2     | 11 Nov 2020 | J. Charlier | bug fix for 8x23 encoding
0.3     | 12 Nov 2020 | J. Charlier | bug fix for 8x23 encoding
0.4     | 13 Nov 2020 | J. Charlier | bug fix for 8x23 encoding
0.5     | 13 Dec 2020 | J. Charlier | update for NB & LR
0.6     | 26 Dec 2020 | J. Charlier | update for LSTM & GRU
0.7     | 27 Dec 2020 | J. Charlier | update for LSTM & GRU
0.8     | 28 Dec 2020 | J. Charlier | update for LSTM & GRU
===============================================
"""
#
#
from __future__ import print_function
import os
import time
import random
random.seed(42)
import numpy as np
import pandas as pd
import seaborn as sns
import pickle as pkl
import matplotlib.pyplot as plt
from sklearn.model_selection import (train_test_split, GridSearchCV)
from sklearn.metrics import (classification_report, roc_auc_score,
                             confusion_matrix, f1_score,
                             roc_curve, precision_score, recall_score,
                             auc, average_precision_score, 
                             precision_recall_curve, accuracy_score)
from sklearn.preprocessing import normalize
from sklearn.ensemble import RandomForestClassifier
from sklearn.linear_model import LogisticRegression as LR
from sklearn.svm import SVC
import tensorflow as tf
import tensorflow.python.keras
from keras.wrappers.scikit_learn import KerasClassifier
from keras.utils import to_categorical
from tensorflow.python.keras.models import Sequential, Model
from tensorflow.python.keras.layers import (Conv2D, MaxPooling2D, MaxPool2D,
                                            concatenate, BatchNormalization, 
                                            Dense, Dropout, Flatten, Input)
from tensorflow.python.keras.preprocessing.image import (ImageDataGenerator,
                                       img_to_array, 
                                       array_to_img)
# import tensorflow.python.keras as tfkeras
from tensorflow.python.keras import backend as K
from tensorflow.python.keras import (models, layers)
from tensorflow.python.keras.wrappers.scikit_learn import KerasClassifier
#
import utilities, ffns, cnns, mltrees, rnns
#
#
# Incorporating reduced learning and early stopping for NN callback
reduce_learning = tf.keras.callbacks.ReduceLROnPlateau(
    monitor='val_loss', factor=0.2, 
    patience=8, verbose=1, 
    mode='auto', min_delta=0.02, 
    cooldown=0, min_lr=0)
eary_stopping = tf.keras.callbacks.EarlyStopping(
    monitor='val_loss', min_delta=0.0001,
    patience=20, verbose=1, mode='auto')
callbacks = [reduce_learning, eary_stopping]
#
#
# data read
# -*-*-*-*-
imgrows = 4
nexp = 3
imgcols = 23
num_classes = 2
epochs = 500
batch_size = 64
ismodelsaved = True   
undersampling = False
flpath = '/content/drive/My Drive/crispor/data/'
#
print('\n\n')
print('!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!')
print('!!!       PREDICTIONS ON CRISPOR             !!!')
print('!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!')
#
print('\n!!! DATA PIPELINE !!!\n')
loaddata = utilities.importData(
    flpath=flpath,
    encoding=str(imgrows) + 'x' + str(imgcols),
    sim='crispor',
    tl=False)
x_train, x_test, y_train, y_test = train_test_split(
    loaddata.images,
    pd.Series(loaddata.target), #loaddata.target,
    test_size=0.3,
    shuffle=True, 
    random_state=42)
xtraincnn, xtestcnn, ytraincnn, ytestcnn, inputshapecnn = cnns.transformImages(
    x_train, x_test,
    y_train, y_test,
    imgrows, imgcols,
    num_classes)
xtrainffn, xtestffn, ytrainfnn, ytestffn, inputshapeffn = ffns.transformImages(
    x_train, x_test,
    y_train, y_test,
    imgrows, imgcols,
    num_classes)
xtrainrf, xtestrf, ytrainrf, ytestrf = mltrees.transformImages(
    x_train, x_test,
    y_train, y_test,
    imgrows, imgcols)
#
print('\n!!! TRAINING PIPELINE !!!\n')
print('\n!!! train fnns !!!\n')
ffn3 = ffns.ffnthree(
    xtrainffn, ytrainfnn,
    xtestffn, ytestffn,
    inputshapeffn, num_classes,
    batch_size, epochs,
    callbacks,
    ismodelsaved=ismodelsaved)
ffn5 = ffns.ffnfive(
    xtrainffn, ytrainfnn,
    xtestffn, ytestffn,
    inputshapeffn, num_classes,
    batch_size, epochs,
    callbacks,
    ismodelsaved=ismodelsaved)
ffn10 = ffns.ffnten(
    xtrainffn, ytrainfnn,
    xtestffn, ytestffn,
    inputshapeffn, num_classes,
    batch_size, epochs,
    callbacks,
    ismodelsaved=ismodelsaved)
#
print('\n!!! train rnns !!!\n')
lstmrnn = rnns.lstmmdl(
    x_train,
    ytrainfnn,
    x_test,
    ytestffn,
    num_classes,
    batch_size,
    epochs,
    callbacks,
    imgrows,
    ismodelsaved=ismodelsaved)
grurnn = rnns.grumdl(
    x_train,
    ytrainfnn,
    x_test,
    ytestffn,
    num_classes,
    batch_size,
    epochs,
    callbacks,
    imgrows,
    ismodelsaved=ismodelsaved)
#
print('\n!!! train cnns !!!\n')
cnn3 = cnns.cnnthree(
    xtraincnn, ytraincnn,
    xtestcnn, ytestcnn,
    inputshapecnn, num_classes,
    batch_size, epochs,
    callbacks,
    ismodelsaved=ismodelsaved)
cnn5 = cnns.cnnfive(
    xtraincnn, ytraincnn,
    xtestcnn, ytestcnn,
    inputshapecnn, num_classes,
    batch_size, epochs,
    callbacks,
    ismodelsaved=ismodelsaved)
cnn10 = cnns.cnnten(
    xtraincnn, ytraincnn,
    xtestcnn, ytestcnn,
    inputshapecnn, num_classes,
    batch_size, epochs,
    callbacks,
    ismodelsaved=ismodelsaved)
cnnlin = cnns.cnnlin(
    xtraincnn, ytraincnn,
    xtestcnn, ytestcnn,
    inputshapecnn, num_classes,
    batch_size, epochs,
    callbacks,
    ismodelsaved=ismodelsaved) 
#
print('\n!!! train random forest !!!\n')
rf = mltrees.initFitRF(xtrainrf, ytrainrf)
nb = mltrees.initFitNaiveBayes(xtrainrf, ytrainrf)
lr = mltrees.initFitLogReg(xtrainrf, ytrainrf)
#
print('\n!!! TESTING PIPELINE !!!\n')
print('\n!!!! roc curve on crispor data !!!\n')
mdls = [
    ffn3, ffn5, ffn10,
    cnn3, cnn5, 
    #cnn10, cnnlin,
    lstmrnn, grurnn,
    rf, nb, lr]
mdllbls = [
    'FNN3', 'FNN5', 'FNN10',
    'CNN3', 'CNN5',
    #'CNN10', 'CNN Lin',
    'LSTM', 'GRU',
    'RF', 'NB', 'LR']
mdlxte = [
    xtestffn, xtestffn, xtestffn,
    xtestcnn, xtestcnn,
    #xtestcnn, xtestcnn,
    x_test, x_test,
    xtestrf, xtestrf, xtestrf]
mdlyte = [
    ytestffn, ytestffn, ytestffn,
    ytestcnn, ytestcnn,
    #ytestcnn, ytestcnn,
    ytestffn, ytestffn,
    y_test, y_test, y_test]
utilities.plotRocCurve(
    mdls, mdllbls,
    mdlxte, mdlyte,
    'roccurvecrispr4x23.pdf')
print('\n!!!! precision recall curve on crispor data !!!\n')
utilities.plotPrecisionRecallCurve(
    mdls, mdllbls,
    mdlxte, mdlyte,
    'precisionrecallcurvecrispr4x23.pdf')
#
preds = utilities.collectPreds(mdls, mdlxte)
# correct predictions of Lin et al.
# preds.yscore[-4][:, 1] = np.abs(preds.yscore[-4][:, 1])
# for n in range(len(preds.yscore[-4])):
#     under = preds.yscore[-4][n, 0] + preds.yscore[-4][n, 1]
#     preds.yscore[-4][n, 0] = preds.yscore[-4][n, 0] / (under)
#     preds.yscore[-4][n, 1] = preds.yscore[-4][n, 1] / (under)
#
objfuns = [
    utilities.brierScore, accuracy_score,
    f1_score, precision_score, recall_score]
for objfun in objfuns:
    if 'brier' in str(objfun):
        utilities.computeScore(
            objfun,
            y_test,
            preds.yscore,
            mdllbls)
    else:
        utilities.computeScore(
            objfun,
            y_test,
            preds.ypred,
            mdllbls)
#
utilities.printTopPreds(
    cnn3,
    xtestcnn,
    y_test,
    loaddata.target_names,
    imgrows)
#
#
print('\n\n')
print('!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!')
print('!!!       PREDICTIONS ON GUIDE SEQ           !!!')
print('!!!       RESULTS FOR PUBLICATION            !!!')
print('!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!')
#
print('\n!!! DATA PIPELINE !!!\n')
loadguideseq = utilities.importData(
    flpath=flpath,
    encoding=str(imgrows)+'x'+str(imgcols),
    sim='guideseq',
    tl=False)
gseq = utilities.transformGuideSeqImages(
		loadguideseq,
		num_classes,
		imgrows, imgcols)
#
print('\n!!! TRAINING PIPELINE !!!\n')
print('transfer learning: no training required.')
#
print('\n!!! TESTING PIPELINE !!!\n')
print('\n!!!! roc curve on guideseq data !!!\n')
mdlxte = [
    gseq.xgseqffn, gseq.xgseqffn, gseq.xgseqffn,
    gseq.xgseqcnn, gseq.xgseqcnn,
    #gseq.xgseqcnn, gseq.xgseqcnn,
    loadguideseq.images, loadguideseq.images,
    gseq.xgseqrf, gseq.xgseqrf, gseq.xgseqrf]
mdlyte = [
    gseq.ygseqffn, gseq.ygseqffn, gseq.ygseqffn,
    gseq.ygseqcnn, gseq.ygseqcnn,
    #gseq.ygseqcnn, gseq.ygseqcnn,
    gseq.ygseqffn, gseq.ygseqffn,
    gseq.ygseqrf, gseq.ygseqrf, gseq.ygseqrf]
utilities.plotRocCurve(
    mdls, mdllbls,
    mdlxte, mdlyte,
    'roccurveguideseq4x23.pdf')
print('\n!!!! precision recall curve on guideseq data !!!\n')
utilities.plotPrecisionRecallCurve(
    mdls, mdllbls,
    mdlxte, mdlyte,
    'precisionrecallcurveguideseq4x23.pdf')
predsgseq = utilities.collectPreds(mdls, mdlxte)
#
# correct predictions of Linn et al.
# predsgseq.yscore[-4][:, 1] = np.abs(predsgseq.yscore[-4][:, 1])
# for n in range(len(predsgseq.yscore[-4])):
#     under = predsgseq.yscore[-4][n, 0] + predsgseq.yscore[-4][n, 1]
#     predsgseq.yscore[-4][n, 0] = predsgseq.yscore[-4][n, 0] / (under)
#     predsgseq.yscore[-4][n, 1] = predsgseq.yscore[-4][n, 1] / (under)
#
for objfun in objfuns:
    if 'brier' in str(objfun):
        utilities.computeScore(
            objfun,
            loadguideseq.target,
            predsgseq.yscore,
            mdllbls)
    else:
        utilities.computeScore(
            objfun,
            loadguideseq.target,
            predsgseq.ypred,
            mdllbls)
#
utilities.printTopPreds(
    cnn3,
    xtestcnn,
    gseq.ygseqdf,
    loadguideseq.target_names,
    imgrows)
#
# Last card of module offtargetmodelsexperiments4x23.
#

# -*- coding: utf-8 -*-
"""Perform the Experiments for Off-Target Predictions with 8x23 encoding.
===============================================
Version |    Date     |   Author    |   Comment
-----------------------------------------------
0.0     | 25 Oct 2020 | J. Charlier | initial version
0.1     | 09 Oct 2020 | J. Charlier | update new version
0.2     | 11 Oct 2020 | J. Charlier | bug fix for 8x23 encoding
0.3     | 12 Oct 2020 | J. Charlier | bug fix for 8x23 encoding
0.4     | 13 Dec 2020 | J. Charlier | update for NB & LR
0.5     | 28 Dec 2020 | J. Charlier | update for LSTM & GRU
===============================================
"""
#
#
from __future__ import print_function
import os
import time
import random
random.seed(42)
import numpy as np
import pandas as pd
import seaborn as sns
import pickle as pkl
import matplotlib.pyplot as plt
from sklearn.model_selection import (train_test_split, GridSearchCV)
from sklearn.metrics import (classification_report, roc_auc_score,
                             confusion_matrix, f1_score,
                             roc_curve, precision_score, recall_score,
                             auc, average_precision_score, 
                             precision_recall_curve, accuracy_score)
from sklearn.preprocessing import normalize
from sklearn.ensemble import RandomForestClassifier
from sklearn.linear_model import LogisticRegression as LR
from sklearn.svm import SVC
import tensorflow as tf
import tensorflow.python.keras
from keras.wrappers.scikit_learn import KerasClassifier
from keras.utils import to_categorical
from tensorflow.python.keras.models import Sequential, Model
from tensorflow.python.keras.layers import (Conv2D, MaxPooling2D, MaxPool2D,
                                            concatenate, BatchNormalization, 
                                            Dense, Dropout, Flatten, Input)
from tensorflow.python.keras.preprocessing.image import (ImageDataGenerator,
                                       img_to_array, 
                                       array_to_img)
from tensorflow.python.keras import backend as K
from tensorflow.python.keras import (models, layers)
from tensorflow.python.keras.wrappers.scikit_learn import KerasClassifier
#
import utilities, ffns, cnns, mltrees, rnns
#
#
# Incorporating reduced learning and early stopping for NN callback
reduce_learning = tf.keras.callbacks.ReduceLROnPlateau(
    monitor='val_loss', factor=0.2, 
    patience=8, verbose=1, 
    mode='auto', min_delta=0.02, 
    cooldown=0, min_lr=0)
eary_stopping = tf.keras.callbacks.EarlyStopping(
    monitor='val_loss', min_delta=0.0001,
    patience=20, verbose=1, mode='auto')
callbacks = [reduce_learning, eary_stopping]
#
# global variables
imgrows = 8
nexp = 3
imgcols = 23
num_classes = 2
epochs = 500
batch_size = 64
ismodelsaved = True
undersampling = False
flpath = '/content/drive/My Drive/crispor/data/'
#
print('\n\n')
print('!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!')
print('!!!       PREDICTIONS ON CRISPOR             !!!')
print('!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!')
#
print('\n!!! DATA PIPELINE !!!\n')
loaddata = utilities.importData(
    flpath=flpath,
    encoding=str(imgrows) + 'x' + str(imgcols),
    sim='crispor',
    tl=False)
x_train, x_test, y_train, y_test = train_test_split(
    loaddata.images,
    pd.Series(loaddata.target), #loaddata.target,
    test_size=0.3,
    shuffle=True, 
    random_state=42)
xtrainffn, xtestffn, ytrainfnn, ytestffn, inputshapeffn = ffns.transformImages(
    x_train, x_test,
    y_train, y_test,
    imgrows, imgcols,
    num_classes)
xtraincnn, xtestcnn, ytraincnn, ytestcnn, inputshapecnn = cnns.transformImages(
    x_train, x_test,
    y_train, y_test,
    imgrows, imgcols,
    num_classes)
xtrainrf, xtestrf, ytrainrf, ytestrf = mltrees.transformImages(
    x_train, x_test,
    y_train, y_test,
    imgrows, imgcols)
#
print('\n!!! TRAINING PIPELINE !!!\n')
print('\n!!! train fnns !!!\n')
ffn3 = ffns.ffnthree(
    xtrainffn, ytrainfnn,
    xtestffn, ytestffn,
    inputshapeffn, num_classes,
    batch_size, epochs,
    callbacks,
    ismodelsaved=ismodelsaved)
ffn5 = ffns.ffnfive(
    xtrainffn, ytrainfnn,
    xtestffn, ytestffn,
    inputshapeffn, num_classes,
    batch_size, epochs,
    callbacks,
    ismodelsaved=ismodelsaved)
ffn10 = ffns.ffnten(
    xtrainffn, ytrainfnn,
    xtestffn, ytestffn,
    inputshapeffn, num_classes,
    batch_size, epochs,
    callbacks,
    ismodelsaved=ismodelsaved)
#
print('\n!!! train rnns !!!\n')
lstmrnn = rnns.lstmmdl(
    x_train,
    ytrainfnn,
    x_test,
    ytestffn,
    num_classes,
    batch_size,
    epochs,
    callbacks,
    imgrows,
    ismodelsaved=ismodelsaved)
grurnn = rnns.grumdl(
    x_train,
    ytrainfnn,
    x_test,
    ytestffn,
    num_classes,
    batch_size,
    epochs,
    callbacks,
    imgrows,
    ismodelsaved=ismodelsaved)
#
print('\n!!! train cnns !!!\n')
cnn3 = cnns.cnnthree(
    xtraincnn, ytraincnn,
    xtestcnn, ytestcnn,
    inputshapecnn, num_classes,
    batch_size, epochs,
    callbacks,
    ismodelsaved=ismodelsaved)
cnn5 = cnns.cnnfive(
    xtraincnn, ytraincnn,
    xtestcnn, ytestcnn,
    inputshapecnn, num_classes,
    batch_size, epochs,
    callbacks,
    ismodelsaved=ismodelsaved)
cnn10 = cnns.cnnten(
    xtraincnn, ytraincnn,
    xtestcnn, ytestcnn,
    inputshapecnn, num_classes,
    batch_size, epochs,
    callbacks,
    ismodelsaved=ismodelsaved)
cnnlin = cnns.cnnlin(
    xtraincnn, ytraincnn,
    xtestcnn, ytestcnn,
    inputshapecnn, num_classes,
    batch_size, epochs,
    callbacks,
    ismodelsaved=ismodelsaved) 
#
print('\n!!! train random forest !!!\n')
rf = mltrees.initFitRF(xtrainrf, ytrainrf)
print('\n!!! train naive bayes !!!\n')
nb = mltrees.initFitNaiveBayes(xtrainrf, ytrainrf)
print('\n!!! train logistic regression !!!\n')
lr = mltrees.initFitLogReg(xtrainrf, ytrainrf)
#
print('\n!!! TESTING PIPELINE !!!\n')
print('\n!!!! roc curve on crispor data !!!\n')
mdls = [
    ffn3, ffn5, ffn10,
    cnn3, cnn5, 
    #cnn10, cnnlin,
    lstmrnn, grurnn,
    rf, nb, lr]
mdllbls = [
    'FNN3', 'FNN5', 'FNN10',
    'CNN3', 'CNN5',
    #'CNN10', 'CNN Lin',
    'LSTM', 'GRU',
    'RF', 'NB', 'LR']
mdlxte = [
    xtestffn, xtestffn, xtestffn,
    xtestcnn, xtestcnn,
    #xtestcnn, xtestcnn,
    x_test, x_test,
    xtestrf, xtestrf, xtestrf]
mdlyte = [
    ytestffn, ytestffn, ytestffn,
    ytestcnn, ytestcnn,
    #ytestcnn, ytestcnn,
    ytestffn, ytestffn,
    y_test, y_test, y_test]
utilities.plotRocCurve(
    mdls, mdllbls,
    mdlxte, mdlyte,
    'roccurvecrispr8x23.pdf')
print('\n!!!! precision recall curve on crispor data !!!\n')
utilities.plotPrecisionRecallCurve(
    mdls, mdllbls,
    mdlxte, mdlyte,
    'precisionrecallcurvecrispr8x23.pdf')
#
#
preds = utilities.collectPreds(mdls, mdlxte)
# correct predictions of Linn et al.
# preds.yscore[-4][:, 1] = np.abs(preds.yscore[-4][:, 1])
# for n in range(len(preds.yscore[-4])):
#     under = preds.yscore[-4][n, 0] + preds.yscore[-4][n, 1]
#     preds.yscore[-4][n, 0] = preds.yscore[-4][n, 0] / (under)
#     preds.yscore[-4][n, 1] = preds.yscore[-4][n, 1] / (under)
#
objfuns = [
    utilities.brierScore, accuracy_score,
    f1_score, precision_score, recall_score]
for objfun in objfuns:
    if 'brier' in str(objfun):
        utilities.computeScore(
            objfun,
            y_test,
            preds.yscore,
            mdllbls)
    else:
        utilities.computeScore(
            objfun,
            y_test,
            preds.ypred,
            mdllbls)
#
utilities.printTopPreds(
    cnn3,
    xtestcnn,
    y_test,
    loaddata.target_names,
    imgrows)
#
print('\n\n')
print('!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!')
print('!!!       PREDICTIONS ON GUIDE SEQ           !!!')
print('!!!       RESULTS FOR PUBLICATION            !!!')
print('!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!')
print('\n!!! DATA PIPELINE !!!\n')
print('\n!!! reload dl for transfer learning !!!\n')
loaddata = utilities.importData(
    flpath=flpath,
    encoding=str(imgrows) + 'x' + str(imgcols),
    sim='crispor',
    tl=True)
x_train, x_test, y_train, y_test = train_test_split(
    loaddata.images,
    pd.Series(loaddata.target), #loaddata.target,
    test_size=0.3,
    shuffle=True, 
    random_state=42)
xtrainrf, xtestrf, ytrainrf, ytestrf = mltrees.transformImages(
    x_train, x_test,
    y_train, y_test,
    imgrows, imgcols)
#
ffn3 = ffns.ffnthree(
    xtrainffn, ytrainfnn,
    xtestffn, ytestffn,
    inputshapeffn, num_classes,
    batch_size, epochs,
    callbacks,
    ismodelsaved=ismodelsaved,
    tl=True)
ffn5 = ffns.ffnfive(
    xtrainffn, ytrainfnn,
    xtestffn, ytestffn,
    inputshapeffn, num_classes,
    batch_size, epochs,
    callbacks,
    ismodelsaved=ismodelsaved,
    tl=True)
ffn10 = ffns.ffnten(
    xtrainffn, ytrainfnn,
    xtestffn, ytestffn,
    inputshapeffn, num_classes,
    batch_size, epochs,
    callbacks,
    ismodelsaved=ismodelsaved,
    tl=True)
lstmrnn = rnns.lstmmdl(
    x_train,
    ytrainfnn,
    x_test,
    ytestffn,
    num_classes,
    batch_size,
    epochs,
    callbacks,
    imgrows,
    ismodelsaved=ismodelsaved,
    tl=True)
grurnn = rnns.grumdl(
    x_train,
    ytrainfnn,
    x_test,
    ytestffn,
    num_classes,
    batch_size,
    epochs,
    callbacks,
    imgrows,
    ismodelsaved=ismodelsaved,
    tl=True)
cnn3 = cnns.cnnthree(
    xtraincnn, ytraincnn,
    xtestcnn, ytestcnn,
    inputshapecnn, num_classes,
    batch_size, epochs,
    callbacks,
    ismodelsaved=ismodelsaved,
    tl=True)
cnn5 = cnns.cnnfive(
    xtraincnn, ytraincnn,
    xtestcnn, ytestcnn,
    inputshapecnn, num_classes,
    batch_size, epochs,
    callbacks,
    ismodelsaved=ismodelsaved,
    tl=True)
cnn10 = cnns.cnnten(
    xtraincnn, ytraincnn,
    xtestcnn, ytestcnn,
    inputshapecnn, num_classes,
    batch_size, epochs,
    callbacks,
    ismodelsaved=ismodelsaved,
    tl=True)
cnnlin = cnns.cnnlin(
    xtraincnn, ytraincnn,
    xtestcnn, ytestcnn,
    inputshapecnn, num_classes,
    batch_size, epochs,
    callbacks,
    ismodelsaved=ismodelsaved,
    tl=True)
rf = mltrees.initFitRF(xtrainrf, ytrainrf)
nb = mltrees.initFitNaiveBayes(xtrainrf, ytrainrf)
lr = mltrees.initFitLogReg(xtrainrf, ytrainrf)
#
print('\n!!! import guideseq data !!!\n')
loadguideseq = utilities.importData(
    flpath=flpath,
    encoding=str(imgrows) + 'x' + str(imgcols),
    sim='guideseq',
    tl=True)
gseq = utilities.transformGuideSeqImages(
		loadguideseq,
		num_classes,
		imgrows, imgcols)
print('\n!!!! roc curve on guideseq data !!!\n')
mdls = [
    ffn3, ffn5, ffn10,
    cnn3, cnn5,
    #cnn10, cnnlin,
    lstmrnn, grurnn,
    rf, nb, lr]
mdlxte = [
    gseq.xgseqffn, gseq.xgseqffn, gseq.xgseqffn,
    gseq.xgseqcnn, gseq.xgseqcnn,
    #gseq.xgseqcnn, gseq.xgseqcnn,
    loadguideseq.images, loadguideseq.images,
    gseq.xgseqrf, gseq.xgseqrf, gseq.xgseqrf]
mdlyte = [
    gseq.ygseqffn, gseq.ygseqffn, gseq.ygseqffn,
    gseq.ygseqcnn, gseq.ygseqcnn,
    #gseq.ygseqcnn, gseq.ygseqcnn,
    gseq.ygseqffn, gseq.ygseqffn,
    gseq.ygseqrf, gseq.ygseqrf, gseq.ygseqrf]
utilities.plotRocCurve(
    mdls, mdllbls, mdlxte, mdlyte,
    'roccurveguideseq8x23.pdf')
print('\n!!!! precision recall curve on guideseq data !!!\n')
utilities.plotPrecisionRecallCurve(
    mdls, mdllbls, mdlxte, mdlyte,
    'precisionrecallcurveguideseq8x23.pdf')
predsgseq = utilities.collectPreds(mdls, mdlxte)
# correct predictions of Linn et al.
# predsgseq.yscore[-4][:, 1] = np.abs(predsgseq.yscore[-4][:, 1])
# for n in range(len(predsgseq.yscore[-4])):
#     under = predsgseq.yscore[-4][n, 0] + predsgseq.yscore[-4][n, 1]
#     predsgseq.yscore[-4][n, 0] = predsgseq.yscore[-4][n, 0] / (under)
#     predsgseq.yscore[-4][n, 1] = predsgseq.yscore[-4][n, 1] / (under)
#
for objfun in objfuns:
    if 'brier' in str(objfun):
        utilities.computeScore(
            objfun,
            loadguideseq.target,
            predsgseq.yscore,
            mdllbls)
    else:
        utilities.computeScore(
            objfun,
            loadguideseq.target,
            predsgseq.ypred,
            mdllbls)
#
utilities.printTopPreds(
    cnn3,
    xtestcnn,
    gseq.ygseqdf,
    loadguideseq.target_names,
    imgrows)
#
# Last card of module offtargetmodelsexperiments8x23.
#

stop





# -*- coding: utf-8 -*-
"""Perform the Experiments for Off-Target Predictions.
===============================================
Version |    Date     |   Author    |   Comment
-----------------------------------------------
0.0     | 25 Oct 2020 | J. Charlier | initial version
0.1     | 09 Oct 2020 | J. Charlier | update new version
0.2     | 11 Oct 2020 | J. Charlier | bug fix for 8x23 encoding
0.3     | 12 Oct 2020 | J. Charlier | bug fix for 8x23 encoding
0.4     | 13 Dec 2020 | J. Charlier | update for NB & LR
===============================================
"""
#
#
from __future__ import print_function
import os
import time
import random
random.seed(42)
import numpy as np
import pandas as pd
import seaborn as sns
import pickle as pkl
import matplotlib.pyplot as plt
from sklearn.model_selection import (train_test_split, GridSearchCV)
from sklearn.metrics import (classification_report, roc_auc_score,
                             confusion_matrix, f1_score,
                             roc_curve, precision_score, recall_score,
                             auc, average_precision_score, 
                             precision_recall_curve, accuracy_score)
from sklearn.preprocessing import normalize
from sklearn.ensemble import RandomForestClassifier
from sklearn.linear_model import LogisticRegression as LR
from sklearn.svm import SVC
import tensorflow as tf
import tensorflow.python.keras
from keras.wrappers.scikit_learn import KerasClassifier
from keras.utils import to_categorical
from tensorflow.python.keras.models import Sequential, Model
from tensorflow.python.keras.layers import (Conv2D, MaxPooling2D, MaxPool2D,
                                            concatenate, BatchNormalization, 
                                            Dense, Dropout, Flatten, Input)
from tensorflow.python.keras.preprocessing.image import (ImageDataGenerator,
                                       img_to_array, 
                                       array_to_img)
from tensorflow.python.keras import backend as K
from tensorflow.python.keras import (models, layers)
from tensorflow.python.keras.wrappers.scikit_learn import KerasClassifier
#
import utilities
import ffns
import cnns
import mltrees
p = print
#
#
# Incorporating reduced learning and early stopping for NN callback
reduce_learning = tf.keras.callbacks.ReduceLROnPlateau(
    monitor='val_loss', factor=0.2, 
    patience=8, verbose=1, 
    mode='auto', min_delta=0.02, 
    cooldown=0, min_lr=0)
eary_stopping = tf.keras.callbacks.EarlyStopping(
    monitor='val_loss', min_delta=0.0001,
    patience=20, verbose=1, mode='auto')
callbacks = [reduce_learning, eary_stopping]
#
#
ismodelsaved = True   
#
#
# data read
# -*-*-*-*-
imgrows = 8
nexp = 3
imgcols = 23
num_classes = 2
epochs = 500
batch_size = 64
undersampling = False
#
# we import the pkl file containing the data
flpath = '/content/drive/My Drive/crispor/data/'
loaddata = utilities.importData(
    flpath=flpath,
    encoding=str(imgrows) + 'x' + str(imgcols),
    sim='crispor',
    tl=False)
x_train, x_test, y_train, y_test = train_test_split(
    loaddata.images,
    pd.Series(loaddata.target), #loaddata.target,
    test_size=0.3,
    shuffle=True, 
    random_state=42)
#
p('\n!!! train ffns !!!\n')
xtrainffn, xtestffn, ytrainfnn, ytestffn, inputshapeffn = ffns.transformImages(
    x_train, x_test,
    y_train, y_test,
    imgrows, imgcols,
    num_classes)
ffn3 = ffns.ffnthree(
    xtrainffn, ytrainfnn,
    xtestffn, ytestffn,
    inputshapeffn, num_classes,
    batch_size, epochs,
    callbacks,
    ismodelsaved=ismodelsaved)
ffn5 = ffns.ffnfive(
    xtrainffn, ytrainfnn,
    xtestffn, ytestffn,
    inputshapeffn, num_classes,
    batch_size, epochs,
    callbacks,
    ismodelsaved=ismodelsaved)
ffn10 = ffns.ffnten(
    xtrainffn, ytrainfnn,
    xtestffn, ytestffn,
    inputshapeffn, num_classes,
    batch_size, epochs,
    callbacks,
    ismodelsaved=ismodelsaved)
#
p('\n!!! train cnns !!!\n')
xtraincnn, xtestcnn, ytraincnn, ytestcnn, inputshapecnn = cnns.transformImages(
    x_train, x_test,
    y_train, y_test,
    imgrows, imgcols,
    num_classes)
cnn3 = cnns.cnnthree(
    xtraincnn, ytraincnn,
    xtestcnn, ytestcnn,
    inputshapecnn, num_classes,
    batch_size, epochs,
    callbacks,
    ismodelsaved=ismodelsaved)
cnn5 = cnns.cnnfive(
    xtraincnn, ytraincnn,
    xtestcnn, ytestcnn,
    inputshapecnn, num_classes,
    batch_size, epochs,
    callbacks,
    ismodelsaved=ismodelsaved)
cnn10 = cnns.cnnten(
    xtraincnn, ytraincnn,
    xtestcnn, ytestcnn,
    inputshapecnn, num_classes,
    batch_size, epochs,
    callbacks,
    ismodelsaved=ismodelsaved)
cnnlin = cnns.cnnlin(
    xtraincnn, ytraincnn,
    xtestcnn, ytestcnn,
    inputshapecnn, num_classes,
    batch_size, epochs,
    callbacks,
    ismodelsaved=ismodelsaved) 
#
print('\n!!! train random forest !!!\n')
xtrainrf, xtestrf, ytrainrf, ytestrf = mltrees.transformImages(
    x_train, x_test,
    y_train, y_test,
    imgrows, imgcols)
rf = mltrees.initFitRF(xtrainrf, ytrainrf)
print('\n!!! train naive bayes !!!\n')
nb = mltrees.initFitNaiveBayes(xtrainrf, ytrainrf)
print('\n!!! train logistic regression !!!\n')
lr = mltrees.initFitLogReg(xtrainrf, ytrainrf)
#
#
p('\n!!!! roc curve on crispor data !!!\n')
utilities.plotRocCurve(
    [
        ffn3, ffn5,
        ffn10, cnn3,
        cnn5,
        #cnn10,
        #cnnlin,
        rf,
        nb, lr],
    [
        'FFN3', 'FFN5',
        'FFN10', 'CNN3',
        'CNN5',
        #'CNN10',
        #'CNN Lin',
        'RF',
        'NB', 'LR'],
    [
        xtestffn, xtestffn,
        xtestffn, xtestcnn,
        xtestcnn,
        #xtestcnn,
        #xtestcnn,
        xtestrf,
        xtestrf, xtestrf],
    [
        ytestffn, ytestffn,
        ytestffn, ytestcnn,
        ytestcnn,
        #ytestcnn,
        #ytestcnn,
        y_test,
        y_test, y_test],
    'roccurvecrispr8x23.pdf')
p('\n!!!! precision recall curve on crispor data !!!\n')
utilities.plotPrecisionRecallCurve(
    [
        ffn3, ffn5,
        ffn10, cnn3,
        cnn5,
        #cnn10,
        #cnnlin,
        rf,
        nb, lr],
    [
        'FFN3', 'FFN5',
        'FFN10', 'CNN3',
        'CNN5',
        #'CNN10',
        #'CNN Lin',
        'RF',
        'NB', 'LR'],
    [
        xtestffn, xtestffn,
        xtestffn, xtestcnn,
        xtestcnn,
        #xtestcnn,
        #xtestcnn,
        xtestrf,
        xtestrf, xtestrf],
    [
        ytestffn, ytestffn,
        ytestffn, ytestcnn,
        ytestcnn,
        #ytestcnn,
        #ytestcnn,
        y_test,
        y_test, y_test],
    'precisionrecallcurvecrispr8x23.pdf')
#
#
preds = utilities.collectPreds(
    [
        ffn3, ffn5,
        ffn10, cnn3,
        cnn5, cnn10,
        cnnlin, rf,
        nb, lr],
    [
        xtestffn, xtestffn,
        xtestffn, xtestcnn,
        xtestcnn, xtestcnn,
        xtestcnn, xtestrf,
        xtestrf, xtestrf]
)
# correct predictions of Linn et al.
preds.yscore[-4][:, 1] = np.abs(preds.yscore[-4][:, 1])
for n in range(len(preds.yscore[-4])):
    under = preds.yscore[-4][n, 0] + preds.yscore[-4][n, 1]
    preds.yscore[-4][n, 0] = preds.yscore[-4][n, 0] / (under)
    preds.yscore[-4][n, 1] = preds.yscore[-4][n, 1] / (under)
#
mdllbls = [
    'FFN3', 'FFN5', 'FFN10',
    'CNN3', 'CNN5', 'CNN10', 'CNN Lin',
    #'LSTM', 'GRU',
    'RF', 'NB', 'LR']
for objfun in [utilities.brierScore, accuracy_score, f1_score, precision_score, recall_score]:
    if 'brier' in str(objfun):
        utilities.computeScore(
            objfun,
            y_test,
            preds.yscore,
            mdllbls)
    else:
        utilities.computeScore(
            objfun,
            y_test,
            preds.ypred,
            mdllbls)
#
utilities.printTopPreds(
    cnn3,
    xtestcnn,
    y_test,
    loaddata.target_names,
    imgrows)
#
p('\n\n')
p('!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!')
p('!!!       PREDICTIONS ON GUIDE SEQ           !!!')
p('!!!       RESULTS FOR PUBLICATION            !!!')
p('!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!')
print('\n!!! reload dl for transfer learning !!!\n')
loaddata = utilities.importData(
    flpath=flpath,
    encoding=str(imgrows) + 'x' + str(imgcols),
    sim='crispor',
    tl=True)
x_train, x_test, y_train, y_test = train_test_split(
    loaddata.images,
    pd.Series(loaddata.target), #loaddata.target,
    test_size=0.3,
    shuffle=True, 
    random_state=42)
#
ffn3 = ffns.ffnthree(
    xtrainffn, ytrainfnn,
    xtestffn, ytestffn,
    inputshapeffn, num_classes,
    batch_size, epochs,
    callbacks,
    ismodelsaved=ismodelsaved,
    tl=True)
ffn5 = ffns.ffnfive(
    xtrainffn, ytrainfnn,
    xtestffn, ytestffn,
    inputshapeffn, num_classes,
    batch_size, epochs,
    callbacks,
    ismodelsaved=ismodelsaved,
    tl=True)
ffn10 = ffns.ffnten(
    xtrainffn, ytrainfnn,
    xtestffn, ytestffn,
    inputshapeffn, num_classes,
    batch_size, epochs,
    callbacks,
    ismodelsaved=ismodelsaved,
    tl=True)
#
cnn3 = cnns.cnnthree(
    xtraincnn, ytraincnn,
    xtestcnn, ytestcnn,
    inputshapecnn, num_classes,
    batch_size, epochs,
    callbacks,
    ismodelsaved=ismodelsaved,
    tl=True)
cnn5 = cnns.cnnfive(
    xtraincnn, ytraincnn,
    xtestcnn, ytestcnn,
    inputshapecnn, num_classes,
    batch_size, epochs,
    callbacks,
    ismodelsaved=ismodelsaved,
    tl=True)
cnn10 = cnns.cnnten(
    xtraincnn, ytraincnn,
    xtestcnn, ytestcnn,
    inputshapecnn, num_classes,
    batch_size, epochs,
    callbacks,
    ismodelsaved=ismodelsaved,
    tl=True)
cnnlin = cnns.cnnlin(
    xtraincnn, ytraincnn,
    xtestcnn, ytestcnn,
    inputshapecnn, num_classes,
    batch_size, epochs,
    callbacks,
    ismodelsaved=ismodelsaved,
    tl=True)
xtrainrf, xtestrf, ytrainrf, ytestrf = mltrees.transformImages(
    x_train, x_test,
    y_train, y_test,
    imgrows, imgcols)
rf = mltrees.initFitRF(xtrainrf, ytrainrf)
nb = mltrees.initFitNaiveBayes(xtrainrf, ytrainrf)
lr = mltrees.initFitLogReg(xtrainrf, ytrainrf)
#
loadguideseq = utilities.importData(
    flpath=flpath,
    encoding=str(imgrows) + 'x' + str(imgcols),
    sim='guideseq',
    tl=True)
gseq = utilities.transformGuideSeqImages(
		loadguideseq,
		num_classes,
		imgrows, imgcols)
p('\n!!!! roc curve on guideseq data !!!\n')
utilities.plotRocCurve(
    [
        ffn3, ffn5,
        ffn10, cnn3,
        cnn5,
        #cnn10,
        #cnnlin,
        rf,
        nb, lr],
    [
        'FFN3', 'FFN5',
        'FFN10', 'CNN3',
        'CNN5',
        #'CNN10',
        #'CNN Lin',
        'RF',
        'NB', 'LR'],
    [
        gseq.xgseqffn, gseq.xgseqffn,
        gseq.xgseqffn, gseq.xgseqcnn,
        gseq.xgseqcnn,
        #gseq.xgseqcnn,
        #gseq.xgseqcnn,
        gseq.xgseqrf,
        gseq.xgseqrf, gseq.xgseqrf],
    [
        gseq.ygseqffn, gseq.ygseqffn,
        gseq.ygseqffn, gseq.ygseqcnn,
        gseq.ygseqcnn,
        #gseq.ygseqcnn,
        #gseq.ygseqcnn,
        gseq.ygseqrf,
        gseq.ygseqrf, gseq.ygseqrf],
    'roccurveguideseq8x23.pdf')
p('\n!!!! precision recall curve on guideseq data !!!\n')
utilities.plotPrecisionRecallCurve(
    [
        ffn3, ffn5,
        ffn10, cnn3,
        cnn5,
        #cnn10,
        #cnnlin,
        rf,
        nb, lr],
    [
        'FFN3', 'FFN5',
        'FFN10', 'CNN3',
        'CNN5',
        #'CNN10',
        #'CNN Lin',
        'RF',
        'NB', 'LR'],
    [
        gseq.xgseqffn, gseq.xgseqffn,
        gseq.xgseqffn, gseq.xgseqcnn,
        gseq.xgseqcnn,
        #gseq.xgseqcnn,
        #gseq.xgseqcnn,
        gseq.xgseqrf,
        gseq.xgseqrf, gseq.xgseqrf],
    [
        gseq.ygseqffn, gseq.ygseqffn,
        gseq.ygseqffn, gseq.ygseqcnn,
        gseq.ygseqcnn,
        #gseq.ygseqcnn,
        #gseq.ygseqcnn,
        gseq.ygseqrf,
        gseq.ygseqrf, gseq.ygseqrf],
    'precisionrecallcurveguideseq8x23.pdf')
predsgseq = utilities.collectPreds(
    [
        ffn3, ffn5,
        ffn10, cnn3,
        cnn5, cnn10,
        cnnlin, rf,
        nb, lr],
    [
        gseq.xgseqffn, gseq.xgseqffn,
        gseq.xgseqffn, gseq.xgseqcnn,
        gseq.xgseqcnn, gseq.xgseqcnn,
        gseq.xgseqcnn, gseq.xgseqrf,
        gseq.xgseqrf, gseq.xgseqrf])
# correct predictions of Linn et al.
predsgseq.yscore[-4][:, 1] = np.abs(predsgseq.yscore[-4][:, 1])
for n in range(len(predsgseq.yscore[-4])):
    under = predsgseq.yscore[-4][n, 0] + predsgseq.yscore[-4][n, 1]
    predsgseq.yscore[-4][n, 0] = predsgseq.yscore[-4][n, 0] / (under)
    predsgseq.yscore[-4][n, 1] = predsgseq.yscore[-4][n, 1] / (under)
#
for objfun in [utilities.brierScore, accuracy_score, f1_score, precision_score, recall_score]:
    if 'brier' in str(objfun):
        utilities.computeScore(
            objfun,
            loadguideseq.target,
            predsgseq.yscore,
            mdllbls)
    else:
        utilities.computeScore(
            objfun,
            loadguideseq.target,
            predsgseq.ypred,
            mdllbls)
#
utilities.printTopPreds(
    cnn3,
    xtestcnn,
    gseq.ygseqdf,
    loadguideseq.target_names,
    imgrows)
#
# Last card of module offtargetmodelsexperiments8x23.
#







# -*- coding: utf-8 -*-
"""Perform the Experiments for Off-Target Predictions.
===============================================
Version |    Date     |   Author    |   Comment
-----------------------------------------------
0.0     | 25 Oct 2020 | J. Charlier | initial version
0.1     | 09 Nov 2020 | J. Charlier | update new version
0.2     | 11 Nov 2020 | J. Charlier | bug fix for 8x23 encoding
0.3     | 12 Nov 2020 | J. Charlier | bug fix for 8x23 encoding
0.4     | 13 Nov 2020 | J. Charlier | bug fix for 8x23 encoding
0.5     | 13 Dec 2020 | J. Charlier | update for NB & LR
0.6     | 26 Dec 2020 | J. Charlier | update for LSTM & GRU
0.7     | 27 Dec 2020 | J. Charlier | update for LSTM & GRU
===============================================
"""
#
#
from __future__ import print_function
import os
import time
import random
random.seed(42)
import numpy as np
import pandas as pd
import seaborn as sns
import pickle as pkl
import matplotlib.pyplot as plt
from sklearn.model_selection import (train_test_split, GridSearchCV)
from sklearn.metrics import (classification_report, roc_auc_score,
                             confusion_matrix, f1_score,
                             roc_curve, precision_score, recall_score,
                             auc, average_precision_score, 
                             precision_recall_curve, accuracy_score)
from sklearn.preprocessing import normalize
from sklearn.ensemble import RandomForestClassifier
from sklearn.linear_model import LogisticRegression as LR
from sklearn.svm import SVC
import tensorflow as tf
import tensorflow.python.keras
from keras.wrappers.scikit_learn import KerasClassifier
from keras.utils import to_categorical
from tensorflow.python.keras.models import Sequential, Model
from tensorflow.python.keras.layers import (Conv2D, MaxPooling2D, MaxPool2D,
                                            concatenate, BatchNormalization, 
                                            Dense, Dropout, Flatten, Input)
from tensorflow.python.keras.preprocessing.image import (ImageDataGenerator,
                                       img_to_array, 
                                       array_to_img)
# import tensorflow.python.keras as tfkeras
from tensorflow.python.keras import backend as K
from tensorflow.python.keras import (models, layers)
from tensorflow.python.keras.wrappers.scikit_learn import KerasClassifier
#
import utilities, ffns, cnns, mltrees, rnns
#
#
# Incorporating reduced learning and early stopping for NN callback
reduce_learning = tf.keras.callbacks.ReduceLROnPlateau(
    monitor='val_loss', factor=0.2, 
    patience=8, verbose=1, 
    mode='auto', min_delta=0.02, 
    cooldown=0, min_lr=0)
eary_stopping = tf.keras.callbacks.EarlyStopping(
    monitor='val_loss', min_delta=0.0001,
    patience=20, verbose=1, mode='auto')
callbacks = [reduce_learning, eary_stopping]
#
#
# data read
# -*-*-*-*-
imgrows = 8
nexp = 3
imgcols = 23
num_classes = 2
epochs = 500
batch_size = 64
ismodelsaved = True   
undersampling = False
flpath = '/content/drive/My Drive/crispor/data/'
#
print('\n\n')
print('!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!')
print('!!!       PREDICTIONS ON CRISPOR             !!!')
print('!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!')
#
print('\n!!! DATA PIPELINE !!!\n')
loaddata = utilities.importData(
    flpath=flpath,
    encoding=str(imgrows) + 'x' + str(imgcols),
    sim='crispor',
    tl=False)
x_train, x_test, y_train, y_test = train_test_split(
    loaddata.images,
    pd.Series(loaddata.target), #loaddata.target,
    test_size=0.3,
    shuffle=True, 
    random_state=42)
xtraincnn, xtestcnn, ytraincnn, ytestcnn, inputshapecnn = cnns.transformImages(
    x_train, x_test,
    y_train, y_test,
    imgrows, imgcols,
    num_classes)
xtrainffn, xtestffn, ytrainfnn, ytestffn, inputshapeffn = ffns.transformImages(
    x_train, x_test,
    y_train, y_test,
    imgrows, imgcols,
    num_classes)
xtrainrf, xtestrf, ytrainrf, ytestrf = mltrees.transformImages(
    x_train, x_test,
    y_train, y_test,
    imgrows, imgcols)
#
print('\n!!! TRAINING PIPELINE !!!\n')
print('\n!!! train ffns !!!\n')
ffn3 = ffns.ffnthree(
    xtrainffn, ytrainfnn,
    xtestffn, ytestffn,
    inputshapeffn, num_classes,
    batch_size, epochs,
    callbacks,
    ismodelsaved=ismodelsaved)
ffn5 = ffns.ffnfive(
    xtrainffn, ytrainfnn,
    xtestffn, ytestffn,
    inputshapeffn, num_classes,
    batch_size, epochs,
    callbacks,
    ismodelsaved=ismodelsaved)
ffn10 = ffns.ffnten(
    xtrainffn, ytrainfnn,
    xtestffn, ytestffn,
    inputshapeffn, num_classes,
    batch_size, epochs,
    callbacks,
    ismodelsaved=ismodelsaved)
#
print('\n!!! train rnns !!!\n')
lstmrnn = rnns.lstmmdl(
    x_train,
    ytrainfnn,
    x_test,
    ytestffn,
    num_classes,
    batch_size,
    epochs,
    callbacks,
    ismodelsaved=False)
grurnn = rnns.grumdl(
    x_train,
    ytrainfnn,
    x_test,
    ytestffn,
    num_classes,
    batch_size,
    epochs,
    callbacks,
    ismodelsaved=False)
#
print('\n!!! train cnns !!!\n')
cnn3 = cnns.cnnthree(
    xtraincnn, ytraincnn,
    xtestcnn, ytestcnn,
    inputshapecnn, num_classes,
    batch_size, epochs,
    callbacks,
    ismodelsaved=ismodelsaved)
cnn5 = cnns.cnnfive(
    xtraincnn, ytraincnn,
    xtestcnn, ytestcnn,
    inputshapecnn, num_classes,
    batch_size, epochs,
    callbacks,
    ismodelsaved=ismodelsaved)
cnn10 = cnns.cnnten(
    xtraincnn, ytraincnn,
    xtestcnn, ytestcnn,
    inputshapecnn, num_classes,
    batch_size, epochs,
    callbacks,
    ismodelsaved=ismodelsaved)
cnnlin = cnns.cnnlin(
    xtraincnn, ytraincnn,
    xtestcnn, ytestcnn,
    inputshapecnn, num_classes,
    batch_size, epochs,
    callbacks,
    ismodelsaved=ismodelsaved) 
#
print('\n!!! train random forest !!!\n')
rf = mltrees.initFitRF(xtrainrf, ytrainrf)
nb = mltrees.initFitNaiveBayes(xtrainrf, ytrainrf)
lr = mltrees.initFitLogReg(xtrainrf, ytrainrf)
#
print('\n!!! TESTING PIPELINE !!!\n')
print('\n!!!! roc curve on crispor data !!!\n')
mdls = [
    ffn3, ffn5, ffn10,
    cnn3, cnn5, 
    #cnn10, cnnlin,
    lstmrnn, grurnn,
    rf, nb, lr]
mdllbls = [
    'FFN3', 'FFN5', 'FFN10',
    'CNN3', 'CNN5',
    #'CNN10', 'CNN Lin',
    'LSTM', 'GRU',
    'RF', 'NB', 'LR']
mdlxte = [
    xtestffn, xtestffn, xtestffn,
    xtestcnn, xtestcnn,
    #xtestcnn, xtestcnn,
    x_test, x_test,
    xtestrf, xtestrf, xtestrf]
mdlyte = [
    ytestffn, ytestffn, ytestffn,
    ytestcnn, ytestcnn,
    #ytestcnn, ytestcnn,
    ytestffn, ytestffn,
    y_test, y_test, y_test]
utilities.plotRocCurve(
    mdls, mdllbls,
    mdlxte, mdlyte,
    'roccurvecrispr8x23.pdf')
print('\n!!!! precision recall curve on crispor data !!!\n')
utilities.plotPrecisionRecallCurve(
    mdls, mdllbls,
    mdlxte, mdlyte,
    'precisionrecallcurvecrispr8x23.pdf')
#
preds = utilities.collectPreds(mdls, mdlxte)
# correct predictions of Linn et al.
# preds.yscore[-4][:, 1] = np.abs(preds.yscore[-4][:, 1])
# for n in range(len(preds.yscore[-4])):
#     under = preds.yscore[-4][n, 0] + preds.yscore[-4][n, 1]
#     preds.yscore[-4][n, 0] = preds.yscore[-4][n, 0] / (under)
#     preds.yscore[-4][n, 1] = preds.yscore[-4][n, 1] / (under)
#
objfuns = [
    utilities.brierScore, accuracy_score,
    f1_score, precision_score, recall_score]
for objfun in objfuns:
    if 'brier' in str(objfun):
        utilities.computeScore(
            objfun,
            y_test,
            preds.yscore,
            mdllbls)
    else:
        utilities.computeScore(
            objfun,
            y_test,
            preds.ypred,
            mdllbls)
#
utilities.printTopPreds(
    cnn3,
    xtestcnn,
    y_test,
    loaddata.target_names,
    imgrows)
#
#
print('\n\n')
print('!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!')
print('!!!       PREDICTIONS ON GUIDE SEQ           !!!')
print('!!!       RESULTS FOR PUBLICATION            !!!')
print('!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!')
#
print('\n!!! DATA PIPELINE !!!\n')
#
# to do
#
print('\n!!! TRAINING PIPELINE !!!\n')
print('transfer learning: no training required.')
#
print('\n!!! TESTING PIPELINE !!!\n')
print('\n!!!! roc curve on guideseq data !!!\n')
#
# to do
#
# Last card of module offtargetmodelsexperiments8x23.
#

print('\n\n')
print('!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!')
print('!!!       PREDICTIONS ON GUIDE SEQ           !!!')
print('!!!       RESULTS FOR PUBLICATION            !!!')
print('!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!')
print('\n!!! DATA PIPELINE !!!\n')
print('\n!!! reload dl for transfer learning !!!\n')
loaddata = utilities.importData(
    flpath=flpath,
    encoding=str(imgrows) + 'x' + str(imgcols),
    sim='crispor',
    tl=True)
x_train, x_test, y_train, y_test = train_test_split(
    loaddata.images,
    pd.Series(loaddata.target), #loaddata.target,
    test_size=0.3,
    shuffle=True, 
    random_state=42)
xtraincnn, xtestcnn, ytraincnn, ytestcnn, inputshapecnn = cnns.transformImages(
    x_train, x_test,
    y_train, y_test,
    imgrows, imgcols,
    num_classes)
xtrainffn, xtestffn, ytrainfnn, ytestffn, inputshapeffn = ffns.transformImages(
    x_train, x_test,
    y_train, y_test,
    imgrows, imgcols,
    num_classes)
xtrainrf, xtestrf, ytrainrf, ytestrf = mltrees.transformImages(
    x_train, x_test,
    y_train, y_test,
    imgrows, imgcols)
loadguideseq = utilities.importData(
    flpath=flpath,
    encoding=str(imgrows) + 'x' + str(imgcols),
    sim='guideseq',
    tl=True)
gseq = utilities.transformGuideSeqImages(
		loadguideseq,
		num_classes,
		imgrows, imgcols)
#
print('\n!!! TRAINING PIPELINE !!!\n')
print('transfer learning: no training required.')
ffn3 = ffns.ffnthree(
    xtrainffn, ytrainfnn,
    xtestffn, ytestffn,
    inputshapeffn, num_classes,
    batch_size, epochs,
    callbacks,
    ismodelsaved=ismodelsaved,
    tl=True)
ffn5 = ffns.ffnfive(
    xtrainffn, ytrainfnn,
    xtestffn, ytestffn,
    inputshapeffn, num_classes,
    batch_size, epochs,
    callbacks,
    ismodelsaved=ismodelsaved,
    tl=True)
ffn10 = ffns.ffnten(
    xtrainffn, ytrainfnn,
    xtestffn, ytestffn,
    inputshapeffn, num_classes,
    batch_size, epochs,
    callbacks,
    ismodelsaved=ismodelsaved,
    tl=True)
# lstmrnn = rnns.lstmmdl(
#     x_train,
#     ytrainfnn,
#     x_test,
#     ytestffn,
#     num_classes,
#     batch_size,
#     epochs,
#     callbacks,
#     ismodelsaved=False)
# grurnn = rnns.grumdl(
#     x_train,
#     ytrainfnn,
#     x_test,
#     ytestffn,
#     num_classes,
#     batch_size,
#     epochs,
#     callbacks,
#     ismodelsaved=False)
cnn3 = cnns.cnnthree(
    xtraincnn, ytraincnn,
    xtestcnn, ytestcnn,
    inputshapecnn, num_classes,
    batch_size, epochs,
    callbacks,
    ismodelsaved=ismodelsaved,
    tl=True)
cnn5 = cnns.cnnfive(
    xtraincnn, ytraincnn,
    xtestcnn, ytestcnn,
    inputshapecnn, num_classes,
    batch_size, epochs,
    callbacks,
    ismodelsaved=ismodelsaved,
    tl=True)
cnn10 = cnns.cnnten(
    xtraincnn, ytraincnn,
    xtestcnn, ytestcnn,
    inputshapecnn, num_classes,
    batch_size, epochs,
    callbacks,
    ismodelsaved=ismodelsaved,
    tl=True)
cnnlin = cnns.cnnlin(
    xtraincnn, ytraincnn,
    xtestcnn, ytestcnn,
    inputshapecnn, num_classes,
    batch_size, epochs,
    callbacks,
    ismodelsaved=ismodelsaved,
    tl=True)
rf = mltrees.initFitRF(xtrainrf, ytrainrf)
nb = mltrees.initFitNaiveBayes(xtrainrf, ytrainrf)
lr = mltrees.initFitLogReg(xtrainrf, ytrainrf)
#
print('\n!!! TESTING PIPELINE !!!\n')
print('\n!!!! roc curve on guideseq data !!!\n')
mdlxte = [
    gseq.xgseqffn, gseq.xgseqffn, gseq.xgseqffn,
    gseq.xgseqcnn, gseq.xgseqcnn,
    #gseq.xgseqcnn, gseq.xgseqcnn,
    loadguideseq.images, loadguideseq.images,
    gseq.xgseqrf, gseq.xgseqrf, gseq.xgseqrf]
mdlyte = [
    gseq.ygseqffn, gseq.ygseqffn, gseq.ygseqffn,
    gseq.ygseqcnn, gseq.ygseqcnn,
    #gseq.ygseqcnn, gseq.ygseqcnn,
    gseq.ygseqffn, gseq.ygseqffn,
    gseq.ygseqrf, gseq.ygseqrf, gseq.ygseqrf]
utilities.plotRocCurve(
    mdls, mdllbls,
    mdlxte, mdlyte,
    'roccurveguideseq8x23.pdf')
print('\n!!!! precision recall curve on guideseq data !!!\n')
utilities.plotPrecisionRecallCurve(
    mdls, mdllbls,
    mdlxte, mdlyte,
    'precisionrecallcurveguideseq8x23.pdf')
predsgseq = utilities.collectPreds(mdls, mdlxte)
#
# correct predictions of Linn et al.
# predsgseq.yscore[-4][:, 1] = np.abs(predsgseq.yscore[-4][:, 1])
# for n in range(len(predsgseq.yscore[-4])):
#     under = predsgseq.yscore[-4][n, 0] + predsgseq.yscore[-4][n, 1]
#     predsgseq.yscore[-4][n, 0] = predsgseq.yscore[-4][n, 0] / (under)
#     predsgseq.yscore[-4][n, 1] = predsgseq.yscore[-4][n, 1] / (under)
#
for objfun in objfuns:
    if 'brier' in str(objfun):
        utilities.computeScore(
            objfun,
            loadguideseq.target,
            predsgseq.yscore,
            mdllbls)
    else:
        utilities.computeScore(
            objfun,
            loadguideseq.target,
            predsgseq.ypred,
            mdllbls)
#
utilities.printTopPreds(
    cnn3,
    xtestcnn,
    gseq.ygseqdf,
    loadguideseq.target_names,
    imgrows)

# -*- coding: utf-8 -*-
"""Perform the Experiments for Off-Target Predictions.
===============================================
Version |    Date     |   Author    |   Comment
-----------------------------------------------
0.0     | 25 Oct 2020 | J. Charlier | initial version
0.1     | 09 Oct 2020 | J. Charlier | update new version
0.2     | 11 Oct 2020 | J. Charlier | bug fix for 8x23 encoding
0.3     | 12 Oct 2020 | J. Charlier | bug fix for 8x23 encoding
0.4     | 13 Dec 2020 | J. Charlier | update for NB & LR
===============================================
"""
#
#
from __future__ import print_function
import os
import time
import random
random.seed(42)
import numpy as np
import pandas as pd
import seaborn as sns
import pickle as pkl
import matplotlib.pyplot as plt
from sklearn.model_selection import (train_test_split, GridSearchCV)
from sklearn.metrics import (classification_report, roc_auc_score,
                             confusion_matrix, f1_score,
                             roc_curve, precision_score, recall_score,
                             auc, average_precision_score, 
                             precision_recall_curve, accuracy_score)
from sklearn.preprocessing import normalize
from sklearn.ensemble import RandomForestClassifier
from sklearn.linear_model import LogisticRegression as LR
from sklearn.svm import SVC
import tensorflow as tf
import tensorflow.python.keras
from keras.wrappers.scikit_learn import KerasClassifier
from keras.utils import to_categorical
from tensorflow.python.keras.models import Sequential, Model
from tensorflow.python.keras.layers import (Conv2D, MaxPooling2D, MaxPool2D,
                                            concatenate, BatchNormalization, 
                                            Dense, Dropout, Flatten, Input)
from tensorflow.python.keras.preprocessing.image import (ImageDataGenerator,
                                       img_to_array, 
                                       array_to_img)
import tensorflow.python.keras as tfkeras
from tensorflow.python.keras import backend as K
from tensorflow.python.keras import (models, layers)
from tensorflow.python.keras.wrappers.scikit_learn import KerasClassifier
#
import utilities
import ffns
import cnns
import mltrees
p = print
#
#
# Incorporating reduced learning and early stopping for NN callback
reduce_learning = tf.keras.callbacks.ReduceLROnPlateau(
    monitor='val_loss', factor=0.2, 
    patience=8, verbose=1, 
    mode='auto', min_delta=0.02, 
    cooldown=0, min_lr=0)
eary_stopping = tf.keras.callbacks.EarlyStopping(
    monitor='val_loss', min_delta=0.0001,
    patience=20, verbose=1, mode='auto')
callbacks = [reduce_learning, eary_stopping]
#
#
ismodelsaved = True   
#
#
# data read
# -*-*-*-*-
imgrows = 8
nexp = 3
imgcols = 23
num_classes = 2
epochs = 500
batch_size = 64
undersampling = False
#
# we import the pkl file containing the data
flpath = '/content/drive/My Drive/crispor/data/'
loaddata = utilities.importData(
    flpath=flpath,
    encoding=str(imgrows) + 'x' + str(imgcols),
    sim='crispor',
    tl=False 
)
#
# the data, split between train and test sets
x_train, x_test, y_train, y_test = train_test_split(
    loaddata.images,
    pd.Series(loaddata.target), #loaddata.target,
    test_size=0.3,
    shuffle=True, 
    random_state=42
)
#
#
p('\n!!! train ffns !!!\n')
xtrainffn, xtestffn, ytrainfnn, ytestffn, inputshapeffn = ffns.transformImages(
    x_train, x_test,
    y_train, y_test,
    imgrows, imgcols,
    num_classes
)
ffn3 = ffns.ffnthree(
    xtrainffn, ytrainfnn,
    xtestffn, ytestffn,
    inputshapeffn, num_classes,
    batch_size, epochs,
    callbacks,
    ismodelsaved=ismodelsaved
)
ffn5 = ffns.ffnfive(
    xtrainffn, ytrainfnn,
    xtestffn, ytestffn,
    inputshapeffn, num_classes,
    batch_size, epochs,
    callbacks,
    ismodelsaved=ismodelsaved
)
ffn10 = ffns.ffnten(
    xtrainffn, ytrainfnn,
    xtestffn, ytestffn,
    inputshapeffn, num_classes,
    batch_size, epochs,
    callbacks,
    ismodelsaved=ismodelsaved
)
#
p('\n!!! train cnns !!!\n')
xtraincnn, xtestcnn, ytraincnn, ytestcnn, inputshapecnn = cnns.transformImages(
    x_train, x_test,
    y_train, y_test,
    imgrows, imgcols,
    num_classes
)
cnn3 = cnns.cnnthree(
    xtraincnn, ytraincnn,
    xtestcnn, ytestcnn,
    inputshapecnn, num_classes,
    batch_size, epochs,
    callbacks,
    ismodelsaved=ismodelsaved
)
cnn5 = cnns.cnnfive(
    xtraincnn, ytraincnn,
    xtestcnn, ytestcnn,
    inputshapecnn, num_classes,
    batch_size, epochs,
    callbacks,
    ismodelsaved=ismodelsaved
)
cnn10 = cnns.cnnten(
    xtraincnn, ytraincnn,
    xtestcnn, ytestcnn,
    inputshapecnn, num_classes,
    batch_size, epochs,
    callbacks,
    ismodelsaved=ismodelsaved
)
cnnlin = cnns.cnnlin(
    xtraincnn, ytraincnn,
    xtestcnn, ytestcnn,
    inputshapecnn, num_classes,
    batch_size, epochs,
    callbacks,
    ismodelsaved=ismodelsaved
) 
#
print('\n!!! train random forest !!!\n')
xtrainrf, xtestrf, ytrainrf, ytestrf = mltrees.transformImages(
    x_train, x_test,
    y_train, y_test,
    imgrows, imgcols
)
rf = mltrees.initFitRF(xtrainrf, ytrainrf)
print('\n!!! train naive bayes !!!\n')
nb = mltrees.initFitNaiveBayes(xtrainrf, ytrainrf)
print('\n!!! train logistic regression !!!\n')
lr = mltrees.initFitLogReg(xtrainrf, ytrainrf)
#
#
p('\n!!!! roc curve on crispor data !!!\n')
utilities.plotRocCurve(
    [
        ffn3, ffn5,
        ffn10, cnn3,
        cnn5,
        #cnn10,
        #cnnlin,
        rf,
        nb, lr
    ],
    [
        'FFN3', 'FFN5',
        'FFN10', 'CNN3',
        'CNN5',
        #'CNN10',
        #'CNN Lin',
        'RF',
        'NB', 'LR'
    ],
    [
        xtestffn, xtestffn,
        xtestffn, xtestcnn,
        xtestcnn,
        #xtestcnn,
        #xtestcnn,
        xtestrf,
        xtestrf, xtestrf
    ],
    [
        ytestffn, ytestffn,
        ytestffn, ytestcnn,
        ytestcnn,
        #ytestcnn,
        #ytestcnn,
        y_test,
        y_test, y_test
    ],
    'roccurvecrispr8x23.pdf'
)
p('\n!!!! precision recall curve on crispor data !!!\n')
utilities.plotPrecisionRecallCurve(
    [
        ffn3, ffn5,
        ffn10, cnn3,
        cnn5,
        #cnn10,
        #cnnlin,
        rf,
        nb, lr
    ],
    [
        'FFN3', 'FFN5',
        'FFN10', 'CNN3',
        'CNN5',
        #'CNN10',
        #'CNN Lin',
        'RF',
        'NB', 'LR'
    ],
    [
        xtestffn, xtestffn,
        xtestffn, xtestcnn,
        xtestcnn,
        #xtestcnn,
        #xtestcnn,
        xtestrf,
        xtestrf, xtestrf
    ],
    [
        ytestffn, ytestffn,
        ytestffn, ytestcnn,
        ytestcnn,
        #ytestcnn,
        #ytestcnn,
        y_test,
        y_test, y_test
    ],
    'precisionrecallcurvecrispr8x23.pdf'
)
#
#
preds = utilities.collectPreds(
    [
        ffn3, ffn5,
        ffn10, cnn3,
        cnn5, cnn10,
        cnnlin, rf,
        nb, lr
    ],
    [
        xtestffn, xtestffn,
        xtestffn, xtestcnn,
        xtestcnn, xtestcnn,
        xtestcnn, xtestrf,
        xtestrf, xtestrf
    ]
)
# correct predictions of Linn et al.
preds.yscore[-4][:, 1] = np.abs(preds.yscore[-4][:, 1])
for n in range(len(preds.yscore[-4])):
    under = preds.yscore[-4][n, 0] + preds.yscore[-4][n, 1]
    preds.yscore[-4][n, 0] = preds.yscore[-4][n, 0] / (under)
    preds.yscore[-4][n, 1] = preds.yscore[-4][n, 1] / (under)
#
for objfun in [utilities.brierScore, accuracy_score, f1_score, precision_score, recall_score]:
    if 'brier' in str(objfun):
        utilities.computeScore(objfun, y_test, preds.yscore)
    else:
        utilities.computeScore(objfun, y_test, preds.ypred)
#
utilities.printTopPreds(
    cnn3,
    xtestcnn,
    y_test,
    loaddata.target_names,
    imgrows
)
#
p('\n\n')
p('!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!')
p('!!!       PREDICTIONS ON GUIDE SEQ           !!!')
p('!!!       RESULTS FOR PUBLICATION            !!!')
p('!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!')
print('\n!!! reload dl for transfer learning !!!\n')
loaddata = utilities.importData(
    flpath=flpath,
    encoding=str(imgrows) + 'x' + str(imgcols),
    sim='crispor',
    tl=True)
x_train, x_test, y_train, y_test = train_test_split(
    loaddata.images,
    pd.Series(loaddata.target), #loaddata.target,
    test_size=0.3,
    shuffle=True, 
    random_state=42)
#
ffn3 = ffns.ffnthree(
    xtrainffn, ytrainfnn,
    xtestffn, ytestffn,
    inputshapeffn, num_classes,
    batch_size, epochs,
    callbacks,
    ismodelsaved=ismodelsaved,
    tl=True
)
ffn5 = ffns.ffnfive(
    xtrainffn, ytrainfnn,
    xtestffn, ytestffn,
    inputshapeffn, num_classes,
    batch_size, epochs,
    callbacks,
    ismodelsaved=ismodelsaved,
    tl=True
)
ffn10 = ffns.ffnten(
    xtrainffn, ytrainfnn,
    xtestffn, ytestffn,
    inputshapeffn, num_classes,
    batch_size, epochs,
    callbacks,
    ismodelsaved=ismodelsaved,
    tl=True
)
#
cnn3 = cnns.cnnthree(
    xtraincnn, ytraincnn,
    xtestcnn, ytestcnn,
    inputshapecnn, num_classes,
    batch_size, epochs,
    callbacks,
    ismodelsaved=ismodelsaved,
    tl=True
)
cnn5 = cnns.cnnfive(
    xtraincnn, ytraincnn,
    xtestcnn, ytestcnn,
    inputshapecnn, num_classes,
    batch_size, epochs,
    callbacks,
    ismodelsaved=ismodelsaved,
    tl=True
)
cnn10 = cnns.cnnten(
    xtraincnn, ytraincnn,
    xtestcnn, ytestcnn,
    inputshapecnn, num_classes,
    batch_size, epochs,
    callbacks,
    ismodelsaved=ismodelsaved,
    tl=True
)
cnnlin = cnns.cnnlin(
    xtraincnn, ytraincnn,
    xtestcnn, ytestcnn,
    inputshapecnn, num_classes,
    batch_size, epochs,
    callbacks,
    ismodelsaved=ismodelsaved,
    tl=True
)
xtrainrf, xtestrf, ytrainrf, ytestrf = mltrees.transformImages(
    x_train, x_test,
    y_train, y_test,
    imgrows, imgcols
)
rf = mltrees.initFitRF(xtrainrf, ytrainrf)
nb = mltrees.initFitNaiveBayes(xtrainrf, ytrainrf)
lr = mltrees.initFitLogReg(xtrainrf, ytrainrf)
#
loadguideseq = utilities.importData(
    flpath=flpath,
    encoding=str(imgrows) + 'x' + str(imgcols),
    sim='guideseq',
    tl=True
)
gseq = utilities.transformGuideSeqImages(
		loadguideseq,
		num_classes,
		imgrows, imgcols
)
p('\n!!!! roc curve on guideseq data !!!\n')
utilities.plotRocCurve(
    [
        ffn3, ffn5,
        ffn10, cnn3,
        cnn5,
        #cnn10,
        #cnnlin,
        rf,
        nb, lr
    ],
    [
        'FFN3', 'FFN5',
        'FFN10', 'CNN3',
        'CNN5',
        #'CNN10',
        #'CNN Lin',
        'RF',
        'NB', 'LR'
    ],
    [
        gseq.xgseqffn, gseq.xgseqffn,
        gseq.xgseqffn, gseq.xgseqcnn,
        gseq.xgseqcnn,
        #gseq.xgseqcnn,
        #gseq.xgseqcnn,
        gseq.xgseqrf,
        gseq.xgseqrf, gseq.xgseqrf
    ],
    [
        gseq.ygseqffn, gseq.ygseqffn,
        gseq.ygseqffn, gseq.ygseqcnn,
        gseq.ygseqcnn,
        #gseq.ygseqcnn,
        #gseq.ygseqcnn,
        gseq.ygseqrf,
        gseq.ygseqrf, gseq.ygseqrf
    ],
    'roccurveguideseq8x23.pdf'
)
p('\n!!!! precision recall curve on guideseq data !!!\n')
utilities.plotPrecisionRecallCurve(
    [
        ffn3, ffn5,
        ffn10, cnn3,
        cnn5,
        #cnn10,
        #cnnlin,
        rf,
        nb, lr
    ],
    [
        'FFN3', 'FFN5',
        'FFN10', 'CNN3',
        'CNN5',
        #'CNN10',
        #'CNN Lin',
        'RF',
        'NB', 'LR'
    ],
    [
        gseq.xgseqffn, gseq.xgseqffn,
        gseq.xgseqffn, gseq.xgseqcnn,
        gseq.xgseqcnn,
        #gseq.xgseqcnn,
        #gseq.xgseqcnn,
        gseq.xgseqrf,
        gseq.xgseqrf, gseq.xgseqrf
    ],
    [
        gseq.ygseqffn, gseq.ygseqffn,
        gseq.ygseqffn, gseq.ygseqcnn,
        gseq.ygseqcnn,
        #gseq.ygseqcnn,
        #gseq.ygseqcnn,
        gseq.ygseqrf,
        gseq.ygseqrf, gseq.ygseqrf
    ],
    'precisionrecallcurveguideseq8x23.pdf'
)
predsgseq = utilities.collectPreds(
    [
        ffn3, ffn5,
        ffn10, cnn3,
        cnn5, cnn10,
        cnnlin, rf,
        nb, lr
    ],
    [
        gseq.xgseqffn, gseq.xgseqffn,
        gseq.xgseqffn, gseq.xgseqcnn,
        gseq.xgseqcnn, gseq.xgseqcnn,
        gseq.xgseqcnn, gseq.xgseqrf,
        gseq.xgseqrf, gseq.xgseqrf
    ]
)
# correct predictions of Linn et al.
predsgseq.yscore[-4][:, 1] = np.abs(predsgseq.yscore[-4][:, 1])
for n in range(len(predsgseq.yscore[-4])):
    under = predsgseq.yscore[-4][n, 0] + predsgseq.yscore[-4][n, 1]
    predsgseq.yscore[-4][n, 0] = predsgseq.yscore[-4][n, 0] / (under)
    predsgseq.yscore[-4][n, 1] = predsgseq.yscore[-4][n, 1] / (under)
#
for objfun in [utilities.brierScore, accuracy_score, f1_score, precision_score, recall_score]:
    if 'brier' in str(objfun):
        utilities.computeScore(objfun, loadguideseq.target, predsgseq.yscore)
    else:
        utilities.computeScore(objfun, loadguideseq.target, predsgseq.ypred)
#
utilities.printTopPreds(
    cnn3,
    xtestcnn,
    gseq.ygseqdf,
    loadguideseq.target_names,
    imgrows
)
#
# Last card of module offtargetmodelsexperiments8x23.
#

loaddata = pkl.load(open(flpath+'encoded8x23withoutTsai.pkl','rb'), encoding='latin1')
x_train, x_test, y_train, y_test = train_test_split(
    loaddata.images,
    pd.Series(loaddata.target), #loaddata.target,
    test_size=0.3,
    shuffle=True, 
    random_state=42
)
x_trainrf = x_train.astype('float32').reshape(-1, imgrows*imgcols)
x_testrf = x_test.astype('float32').reshape(-1, imgrows*imgcols)
x_trainrf /= 255
x_testrf /= 255
print('x_train shape:', x_trainrf.shape)
print(x_trainrf.shape[0], 'train samples')
print(x_testrf.shape[0], 'test samples')
# random forest definition and training
rf = RandomForestClassifier(bootstrap=True, ccp_alpha=0.0, class_weight=None,
                       criterion='gini', max_depth=None, max_features='auto',
                       max_leaf_nodes=None, max_samples=None,
                       min_impurity_decrease=0.0, min_impurity_split=None,
                       min_samples_leaf=1, min_samples_split=2,
                       min_weight_fraction_leaf=0.0, n_estimators=1000,
                       n_jobs=None, oob_score=False, random_state=42,
                       verbose=0, warm_start=False)
rf.fit(x_trainrf, y_train)
print("RF Training: Done")
fpr_rf, tpr_rf, _ = roc_curve(
    y_test, rf.predict_proba(x_testrf)[:,1])
print(np.round(auc(fpr_rf, tpr_rf), 3))
#

loadguideseq = pkl.load(open(flpath+'guideseq8x23.pkl','rb'), encoding='latin1')
# the data, split between train and test sets
x_guideseq = loadguideseq.images
y_guideseq = loadguideseq.target
y_guideseqffn = to_categorical(y_guideseq, num_classes)
y_guideseqcnn = to_categorical(y_guideseq, num_classes)
yguideseqdf = pd.DataFrame(loadguideseq.target, columns=['target'])
yguideseqdf['targetnames'] = loadguideseq.target_names
x_guideseqrf = x_guideseq.astype('float32').reshape(-1, imgrows*imgcols)
x_guideseqrf /= 255

fpr_rf, tpr_rf, _ = roc_curve(
    y_guideseq, rf.predict_proba(x_guideseqrf)[:,1])
print(np.round(auc(fpr_rf, tpr_rf), 3))
fpr_rf, tpr_rf, _ = roc_curve(
    gseq.ygseqrf, rf.predict_proba(gseq.xgseqrf)[:,1])
print(np.round(auc(fpr_rf, tpr_rf), 3))

# older version below

# -*- coding: utf-8 -*-
"""Perform the Experiments for Off-Target Predictions.
===============================================
Version |    Date     |   Author    |   Comment
-----------------------------------------------
0.0     | 25 Oct 2020 | J. Charlier | initial version
0.1     | 09 Nov 2020 | J. Charlier | update new version
0.2     | 11 Nov 2020 | J. Charlier | bug fix for 8x23 encoding
0.3     | 12 Nov 2020 | J. Charlier | bug fix for 8x23 encoding
0.4     | 13 Nov 2020 | J. Charlier | bug fix for 8x23 encoding
===============================================
"""
#
#
from __future__ import print_function
import os
import time
import random
random.seed(42)
import numpy as np
import pandas as pd
import seaborn as sns
import pickle as pkl
import matplotlib.pyplot as plt
from sklearn.model_selection import (train_test_split, GridSearchCV)
from sklearn.metrics import (classification_report, roc_auc_score,
                             confusion_matrix, f1_score,
                             roc_curve, precision_score, recall_score,
                             auc, average_precision_score, 
                             precision_recall_curve, accuracy_score)
from sklearn.preprocessing import normalize
from sklearn.ensemble import RandomForestClassifier
from sklearn.linear_model import LogisticRegression as LR
from sklearn.svm import SVC
import tensorflow as tf
import tensorflow.python.keras
from keras.wrappers.scikit_learn import KerasClassifier
from keras.utils import to_categorical
from tensorflow.python.keras.models import Sequential, Model
from tensorflow.python.keras.layers import (Conv2D, MaxPooling2D, MaxPool2D,
                                            concatenate, BatchNormalization, 
                                            Dense, Dropout, Flatten, Input)
from tensorflow.python.keras.preprocessing.image import (ImageDataGenerator,
                                       img_to_array, 
                                       array_to_img)
import tensorflow.python.keras as tfkeras
from tensorflow.python.keras import backend as K
from tensorflow.python.keras import (models, layers)
from tensorflow.python.keras.wrappers.scikit_learn import KerasClassifier
#
import utilities
import ffns
import cnns
import mltrees
p = print
#
#
# Incorporating reduced learning and early stopping for NN callback
reduce_learning = tf.keras.callbacks.ReduceLROnPlateau(
    monitor='val_loss', factor=0.2, 
    patience=8, verbose=1, 
    mode='auto', min_delta=0.02, 
    cooldown=0, min_lr=0)
eary_stopping = tf.keras.callbacks.EarlyStopping(
    monitor='val_loss', min_delta=0.0001,
    patience=20, verbose=1, mode='auto')
callbacks = [reduce_learning, eary_stopping]
#
#
ismodelsaved = True   
#
#
# data read
# -*-*-*-*-
imgrows = 4
nexp = 3
imgcols = 23
num_classes = 2
epochs = 500
batch_size = 64
undersampling = False
#
# we import the pkl file containing the data
flpath = '/content/drive/My Drive/crispor/data/'
loaddata = utilities.importData(
    flpath=flpath,
    encoding=str(imgrows) + 'x' + str(imgcols),
    sim='crispor',
    tl=False 
)
#
# the data, split between train and test sets
x_train, x_test, y_train, y_test = train_test_split(
    loaddata.images,
    pd.Series(loaddata.target), #loaddata.target,
    test_size=0.3,
    shuffle=True, 
    random_state=42
)
#
#
p('\n!!! train ffns !!!\n')
xtrainffn, xtestffn, ytrainfnn, ytestffn, inputshapeffn = ffns.transformImages(
    x_train, x_test,
    y_train, y_test,
    imgrows, imgcols,
    num_classes
)
ffn3 = ffns.ffnthree(
    xtrainffn, ytrainfnn,
    xtestffn, ytestffn,
    inputshapeffn, num_classes,
    batch_size, epochs,
    callbacks,
    ismodelsaved=ismodelsaved
)
ffn5 = ffns.ffnfive(
    xtrainffn, ytrainfnn,
    xtestffn, ytestffn,
    inputshapeffn, num_classes,
    batch_size, epochs,
    callbacks,
    ismodelsaved=ismodelsaved
)
ffn10 = ffns.ffnten(
    xtrainffn, ytrainfnn,
    xtestffn, ytestffn,
    inputshapeffn, num_classes,
    batch_size, epochs,
    callbacks,
    ismodelsaved=ismodelsaved
)
#
p('\n!!! train cnns !!!\n')
xtraincnn, xtestcnn, ytraincnn, ytestcnn, inputshapecnn = cnns.transformImages(
    x_train, x_test,
    y_train, y_test,
    imgrows, imgcols,
    num_classes
)
cnn3 = cnns.cnnthree(
    xtraincnn, ytraincnn,
    xtestcnn, ytestcnn,
    inputshapecnn, num_classes,
    batch_size, epochs,
    callbacks,
    ismodelsaved=ismodelsaved
)
cnn5 = cnns.cnnfive(
    xtraincnn, ytraincnn,
    xtestcnn, ytestcnn,
    inputshapecnn, num_classes,
    batch_size, epochs,
    callbacks,
    ismodelsaved=ismodelsaved
)
cnn10 = cnns.cnnten(
    xtraincnn, ytraincnn,
    xtestcnn, ytestcnn,
    inputshapecnn, num_classes,
    batch_size, epochs,
    callbacks,
    ismodelsaved=ismodelsaved
)
cnnlin = cnns.cnnlin(
    xtraincnn, ytraincnn,
    xtestcnn, ytestcnn,
    inputshapecnn, num_classes,
    batch_size, epochs,
    callbacks,
    ismodelsaved=ismodelsaved
) 
#
p('\n!!! train random forest !!!\n')
xtrainrf, xtestrf, ytrainrf, ytestrf = mltrees.transformImages(
    x_train, x_test,
    y_train, y_test,
    imgrows, imgcols
)
rf = mltrees.initFitRF(xtrainrf, ytrainrf)
#
#
p('\n!!!! roc curve on crispor data !!!\n')
utilities.plotRocCurve(
    [
        ffn3, ffn5,
        ffn10, cnn3,
        cnn5, cnn10, cnnlin, rf
    ],
    [
        'FFN3', 'FFN5',
        'FFN10', 'CNN3',
        'CNN5', 'CNN10', 'CNN Lin', 'RF'
    ],
    [
        xtestffn, xtestffn,
        xtestffn, xtestcnn,
        xtestcnn, xtestcnn, xtestcnn, xtestrf
    ],
    [
        ytestffn, ytestffn,
        ytestffn, ytestcnn,
        ytestcnn, ytestcnn, ytestcnn, y_test
    ],
    'roccurvecrispr4x23.pdf'
)
p('\n!!!! precision recall curve on crispor data !!!\n')
utilities.plotPrecisionRecallCurve(
    [
        ffn3, ffn5,
        ffn10, cnn3,
        cnn5, cnn10, cnnlin, rf
    ],
    [
        'FFN3', 'FFN5',
        'FFN10', 'CNN3',
        'CNN5', 'CNN10',
        'CNN Lin', 'RF'
    ],
    [
        xtestffn, xtestffn,
        xtestffn, xtestcnn,
        xtestcnn, xtestcnn,
        xtestcnn, xtestrf
    ],
    [
        ytestffn, ytestffn,
        ytestffn, ytestcnn,
        ytestcnn, ytestcnn,
        ytestcnn, y_test
    ],
    'precisionrecallcurvecrispr4x23.pdf'
)
#
#
preds = utilities.collectPreds(
    [
        ffn3, ffn5,
        ffn10, cnn3,
        cnn5, cnn10,
        cnnlin, rf
    ],
    [
        xtestffn, xtestffn,
        xtestffn, xtestcnn,
        xtestcnn, xtestcnn,
        xtestcnn, xtestrf
    ]
)
# correct predictions of Linn et al.
preds.yscore[-2][:, 1] = np.abs(preds.yscore[-2][:, 1])
for n in range(len(preds.yscore[-2])):
    under = preds.yscore[-2][n, 0] + preds.yscore[-2][n, 1]
    preds.yscore[-2][n, 0] = preds.yscore[-2][n, 0] / (under)
    preds.yscore[-2][n, 1] = preds.yscore[-2][n, 1] / (under)
#
for objfun in [utilities.brierScore, accuracy_score, f1_score, precision_score, recall_score]:
    if 'brier' in str(objfun):
        utilities.computeScore(objfun, y_test, preds.yscore)
    else:
        utilities.computeScore(objfun, y_test, preds.ypred)
#
utilities.printTopPreds(
    cnn3,
    xtestcnn,
    y_test,
    loaddata.target_names,
    imgrows
)
#
p('\n\n')
p('!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!')
p('!!!       PREDICTIONS ON GUIDE SEQ           !!!')
p('!!!       RESULTS FOR PUBLICATION            !!!')
p('!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!')
#
loadguideseq = utilities.importData(
    flpath=flpath,
    encoding=str(imgrows)+'x'+str(imgcols),
    sim='guideseq',
    tl=False
)
gseq = utilities.transformGuideSeqImages(
		loadguideseq,
		num_classes,
		imgrows, imgcols
)
p('\n!!!! roc curve on guideseq data !!!\n')
utilities.plotRocCurve(
    [
        ffn3, ffn5,
        ffn10, cnn3,
        cnn5, cnn10, cnnlin, rf
    ],
    [
        'FFN3', 'FFN5',
        'FFN10', 'CNN3',
        'CNN5', 'CNN10', 'CNN Lin', 'RF'
    ],
    [
        gseq.xgseqffn, gseq.xgseqffn,
        gseq.xgseqffn, gseq.xgseqcnn,
        gseq.xgseqcnn, gseq.xgseqcnn,
        gseq.xgseqcnn, gseq.xgseqrf
    ],
    [
        gseq.ygseqffn, gseq.ygseqffn,
        gseq.ygseqffn, gseq.ygseqcnn,
        gseq.ygseqcnn, gseq.ygseqcnn,
        gseq.ygseqcnn, gseq.ygseqrf
    ],
    'roccurveguideseq4x23.pdf'
)
p('\n!!!! precision recall curve on guideseq data !!!\n')
utilities.plotPrecisionRecallCurve(
    [
        ffn3, ffn5,
        ffn10, cnn3,
        cnn5, cnn10, cnnlin, rf
    ],
    [
        'FFN3', 'FFN5',
        'FFN10', 'CNN3',
        'CNN5', 'CNN10', 'CNN Lin', 'RF'
    ],
    [
        gseq.xgseqffn, gseq.xgseqffn,
        gseq.xgseqffn, gseq.xgseqcnn,
        gseq.xgseqcnn, gseq.xgseqcnn,
        gseq.xgseqcnn, gseq.xgseqrf
    ],
    [
        gseq.ygseqffn, gseq.ygseqffn,
        gseq.ygseqffn, gseq.ygseqcnn,
        gseq.ygseqcnn, gseq.ygseqcnn,
        gseq.ygseqcnn, gseq.ygseqrf
    ],
    'precisionrecallcurveguideseq4x23.pdf'
)
predsgseq = utilities.collectPreds(
    [
        ffn3, ffn5,
        ffn10, cnn3,
        cnn5, cnn10,
        cnnlin, rf
    ],
    [
        gseq.xgseqffn, gseq.xgseqffn,
        gseq.xgseqffn, gseq.xgseqcnn,
        gseq.xgseqcnn, gseq.xgseqcnn,
        gseq.xgseqcnn, gseq.xgseqrf
    ]
)
# correct predictions of Linn et al.
predsgseq.yscore[-2][:, 1] = np.abs(predsgseq.yscore[-2][:, 1])
for n in range(len(predsgseq.yscore[-2])):
    under = predsgseq.yscore[-2][n, 0] + predsgseq.yscore[-2][n, 1]
    predsgseq.yscore[-2][n, 0] = predsgseq.yscore[-2][n, 0] / (under)
    predsgseq.yscore[-2][n, 1] = predsgseq.yscore[-2][n, 1] / (under)
#
for objfun in [utilities.brierScore, accuracy_score, f1_score, precision_score, recall_score]:
    if 'brier' in str(objfun):
        utilities.computeScore(objfun, loadguideseq.target, predsgseq.yscore)
    else:
        utilities.computeScore(objfun, loadguideseq.target, predsgseq.ypred)
#
utilities.printTopPreds(
    cnn3,
    xtestcnn,
    gseq.ygseqdf,
    loadguideseq.target_names,
    imgrows
)
#
# Last card of module offtargetmodelsexperiments4x23.
#

# -*- coding: utf-8 -*-
"""Perform the Experiments for Off-Target Predictions.
===============================================
Version |    Date     |   Author    |   Comment
-----------------------------------------------
0.0     | 25 Oct 2020 | J. Charlier | initial version
0.1     | 09 Oct 2020 | J. Charlier | update new version
0.2     | 11 Oct 2020 | J. Charlier | bug fix for 8x23 encoding
0.3     | 12 Oct 2020 | J. Charlier | bug fix for 8x23 encoding
===============================================
"""
#
#
from __future__ import print_function
import os
import time
import random
random.seed(42)
import numpy as np
import pandas as pd
import seaborn as sns
import pickle as pkl
import matplotlib.pyplot as plt
from sklearn.model_selection import (train_test_split, GridSearchCV)
from sklearn.metrics import (classification_report, roc_auc_score,
                             confusion_matrix, f1_score,
                             roc_curve, precision_score, recall_score,
                             auc, average_precision_score, 
                             precision_recall_curve, accuracy_score)
from sklearn.preprocessing import normalize
from sklearn.ensemble import RandomForestClassifier
from sklearn.linear_model import LogisticRegression as LR
from sklearn.svm import SVC
import tensorflow as tf
import tensorflow.python.keras
from keras.wrappers.scikit_learn import KerasClassifier
from keras.utils import to_categorical
from tensorflow.python.keras.models import Sequential, Model
from tensorflow.python.keras.layers import (Conv2D, MaxPooling2D, MaxPool2D,
                                            concatenate, BatchNormalization, 
                                            Dense, Dropout, Flatten, Input)
from tensorflow.python.keras.preprocessing.image import (ImageDataGenerator,
                                       img_to_array, 
                                       array_to_img)
import tensorflow.python.keras as tfkeras
from tensorflow.python.keras import backend as K
from tensorflow.python.keras import (models, layers)
from tensorflow.python.keras.wrappers.scikit_learn import KerasClassifier
#
import utilities
import ffns
import cnns
import mltrees
p = print
#
#
# Incorporating reduced learning and early stopping for NN callback
reduce_learning = tf.keras.callbacks.ReduceLROnPlateau(
    monitor='val_loss', factor=0.2, 
    patience=8, verbose=1, 
    mode='auto', min_delta=0.02, 
    cooldown=0, min_lr=0)
eary_stopping = tf.keras.callbacks.EarlyStopping(
    monitor='val_loss', min_delta=0.0001,
    patience=20, verbose=1, mode='auto')
callbacks = [reduce_learning, eary_stopping]
#
#
ismodelsaved = True   
#
#
# data read
# -*-*-*-*-
imgrows = 8
nexp = 3
imgcols = 23
num_classes = 2
epochs = 500
batch_size = 64
undersampling = False
#
# we import the pkl file containing the data
flpath = '/content/drive/My Drive/crispor/data/'
loaddata = utilities.importData(
    flpath=flpath,
    encoding=str(imgrows) + 'x' + str(imgcols),
    sim='crispor',
    tl=False 
)
#
# the data, split between train and test sets
x_train, x_test, y_train, y_test = train_test_split(
    loaddata.images,
    pd.Series(loaddata.target), #loaddata.target,
    test_size=0.3,
    shuffle=True, 
    random_state=42
)
#
#
p('\n!!! train ffns !!!\n')
xtrainffn, xtestffn, ytrainfnn, ytestffn, inputshapeffn = ffns.transformImages(
    x_train, x_test,
    y_train, y_test,
    imgrows, imgcols,
    num_classes
)
ffn3 = ffns.ffnthree(
    xtrainffn, ytrainfnn,
    xtestffn, ytestffn,
    inputshapeffn, num_classes,
    batch_size, epochs,
    callbacks,
    ismodelsaved=ismodelsaved
)
ffn5 = ffns.ffnfive(
    xtrainffn, ytrainfnn,
    xtestffn, ytestffn,
    inputshapeffn, num_classes,
    batch_size, epochs,
    callbacks,
    ismodelsaved=ismodelsaved
)
ffn10 = ffns.ffnten(
    xtrainffn, ytrainfnn,
    xtestffn, ytestffn,
    inputshapeffn, num_classes,
    batch_size, epochs,
    callbacks,
    ismodelsaved=ismodelsaved
)
#
p('\n!!! train cnns !!!\n')
xtraincnn, xtestcnn, ytraincnn, ytestcnn, inputshapecnn = cnns.transformImages(
    x_train, x_test,
    y_train, y_test,
    imgrows, imgcols,
    num_classes
)
cnn3 = cnns.cnnthree(
    xtraincnn, ytraincnn,
    xtestcnn, ytestcnn,
    inputshapecnn, num_classes,
    batch_size, epochs,
    callbacks,
    ismodelsaved=ismodelsaved
)
cnn5 = cnns.cnnfive(
    xtraincnn, ytraincnn,
    xtestcnn, ytestcnn,
    inputshapecnn, num_classes,
    batch_size, epochs,
    callbacks,
    ismodelsaved=ismodelsaved
)
cnn10 = cnns.cnnten(
    xtraincnn, ytraincnn,
    xtestcnn, ytestcnn,
    inputshapecnn, num_classes,
    batch_size, epochs,
    callbacks,
    ismodelsaved=ismodelsaved
)
cnnlin = cnns.cnnlin(
    xtraincnn, ytraincnn,
    xtestcnn, ytestcnn,
    inputshapecnn, num_classes,
    batch_size, epochs,
    callbacks,
    ismodelsaved=ismodelsaved
) 
#
p('\n!!! train random forest !!!\n')
xtrainrf, xtestrf, ytrainrf, ytestrf = mltrees.transformImages(
    x_train, x_test,
    y_train, y_test,
    imgrows, imgcols
)
rf = mltrees.initFitRF(xtrainrf, ytrainrf)
#
#
p('\n!!!! roc curve on crispor data !!!\n')
utilities.plotRocCurve(
    [
        ffn3, ffn5,
        ffn10, cnn3,
        cnn5, cnn10, cnnlin, rf
    ],
    [
        'FFN3', 'FFN5',
        'FFN10', 'CNN3',
        'CNN5', 'CNN10', 'CNN Lin', 'RF'
    ],
    [
        xtestffn, xtestffn,
        xtestffn, xtestcnn,
        xtestcnn, xtestcnn, xtestcnn, xtestrf
    ],
    [
        ytestffn, ytestffn,
        ytestffn, ytestcnn,
        ytestcnn, ytestcnn, ytestcnn, y_test
    ],
    'roccurvecrispr8x23.pdf'
)
p('\n!!!! precision recall curve on crispor data !!!\n')
utilities.plotPrecisionRecallCurve(
    [
        ffn3, ffn5,
        ffn10, cnn3,
        cnn5, cnn10, cnnlin, rf
    ],
    [
        'FFN3', 'FFN5',
        'FFN10', 'CNN3',
        'CNN5', 'CNN10',
        'CNN Lin', 'RF'
    ],
    [
        xtestffn, xtestffn,
        xtestffn, xtestcnn,
        xtestcnn, xtestcnn,
        xtestcnn, xtestrf
    ],
    [
        ytestffn, ytestffn,
        ytestffn, ytestcnn,
        ytestcnn, ytestcnn,
        ytestcnn, y_test
    ],
    'precisionrecallcurvecrispr8x23.pdf'
)
#
#
preds = utilities.collectPreds(
    [
        ffn3, ffn5,
        ffn10, cnn3,
        cnn5, cnn10,
        cnnlin, rf
    ],
    [
        xtestffn, xtestffn,
        xtestffn, xtestcnn,
        xtestcnn, xtestcnn,
        xtestcnn, xtestrf
    ]
)
# correct predictions of Linn et al.
preds.yscore[-2][:, 1] = np.abs(preds.yscore[-2][:, 1])
for n in range(len(preds.yscore[-2])):
    under = preds.yscore[-2][n, 0] + preds.yscore[-2][n, 1]
    preds.yscore[-2][n, 0] = preds.yscore[-2][n, 0] / (under)
    preds.yscore[-2][n, 1] = preds.yscore[-2][n, 1] / (under)
#
for objfun in [utilities.brierScore, accuracy_score, f1_score, precision_score, recall_score]:
    if 'brier' in str(objfun):
        utilities.computeScore(objfun, y_test, preds.yscore)
    else:
        utilities.computeScore(objfun, y_test, preds.ypred)
#
utilities.printTopPreds(
    cnn3,
    xtestcnn,
    y_test,
    loaddata.target_names,
    imgrows
)
#
p('\n\n')
p('!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!')
p('!!!       PREDICTIONS ON GUIDE SEQ           !!!')
p('!!!       RESULTS FOR PUBLICATION            !!!')
p('!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!')
#
p('\n!!! reload dl for transfer learning !!!\n')
ffn3 = ffns.ffnthree(
    xtrainffn, ytrainfnn,
    xtestffn, ytestffn,
    inputshapeffn, num_classes,
    batch_size, epochs,
    callbacks,
    ismodelsaved=ismodelsaved,
    tl=True
)
ffn5 = ffns.ffnfive(
    xtrainffn, ytrainfnn,
    xtestffn, ytestffn,
    inputshapeffn, num_classes,
    batch_size, epochs,
    callbacks,
    ismodelsaved=ismodelsaved,
    tl=True
)
ffn10 = ffns.ffnten(
    xtrainffn, ytrainfnn,
    xtestffn, ytestffn,
    inputshapeffn, num_classes,
    batch_size, epochs,
    callbacks,
    ismodelsaved=ismodelsaved,
    tl=True
)
#
cnn3 = cnns.cnnthree(
    xtraincnn, ytraincnn,
    xtestcnn, ytestcnn,
    inputshapecnn, num_classes,
    batch_size, epochs,
    callbacks,
    ismodelsaved=ismodelsaved,
    tl=True
)
cnn5 = cnns.cnnfive(
    xtraincnn, ytraincnn,
    xtestcnn, ytestcnn,
    inputshapecnn, num_classes,
    batch_size, epochs,
    callbacks,
    ismodelsaved=ismodelsaved,
    tl=True
)
cnn10 = cnns.cnnten(
    xtraincnn, ytraincnn,
    xtestcnn, ytestcnn,
    inputshapecnn, num_classes,
    batch_size, epochs,
    callbacks,
    ismodelsaved=ismodelsaved,
    tl=True
)
cnnlin = cnns.cnnlin(
    xtraincnn, ytraincnn,
    xtestcnn, ytestcnn,
    inputshapecnn, num_classes,
    batch_size, epochs,
    callbacks,
    ismodelsaved=ismodelsaved,
    tl=True
) 
#
loadguideseq = utilities.importData(
    flpath=flpath,
    encoding=str(imgrows) + 'x' + str(imgcols),
    sim='guideseq',
    tl=False
)
gseq = utilities.transformGuideSeqImages(
		loadguideseq,
		num_classes,
		imgrows, imgcols
)
p('\n!!!! roc curve on guideseq data !!!\n')
utilities.plotRocCurve(
    [
        ffn3, ffn5,
        ffn10, cnn3,
        cnn5, cnn10, cnnlin, rf
    ],
    [
        'FFN3', 'FFN5',
        'FFN10', 'CNN3',
        'CNN5', 'CNN10', 'CNN Lin', 'RF'
    ],
    [
        gseq.xgseqffn, gseq.xgseqffn,
        gseq.xgseqffn, gseq.xgseqcnn,
        gseq.xgseqcnn, gseq.xgseqcnn,
        gseq.xgseqcnn, gseq.xgseqrf
    ],
    [
        gseq.ygseqffn, gseq.ygseqffn,
        gseq.ygseqffn, gseq.ygseqcnn,
        gseq.ygseqcnn, gseq.ygseqcnn,
        gseq.ygseqcnn, gseq.ygseqrf
    ],
    'roccurveguideseq8x23.pdf'
)
p('\n!!!! precision recall curve on guideseq data !!!\n')
utilities.plotPrecisionRecallCurve(
    [
        ffn3, ffn5,
        ffn10, cnn3,
        cnn5, cnn10, cnnlin, rf
    ],
    [
        'FFN3', 'FFN5',
        'FFN10', 'CNN3',
        'CNN5', 'CNN10', 'CNN Lin', 'RF'
    ],
    [
        gseq.xgseqffn, gseq.xgseqffn,
        gseq.xgseqffn, gseq.xgseqcnn,
        gseq.xgseqcnn, gseq.xgseqcnn,
        gseq.xgseqcnn, gseq.xgseqrf
    ],
    [
        gseq.ygseqffn, gseq.ygseqffn,
        gseq.ygseqffn, gseq.ygseqcnn,
        gseq.ygseqcnn, gseq.ygseqcnn,
        gseq.ygseqcnn, gseq.ygseqrf
    ],
    'precisionrecallcurveguideseq8x23.pdf'
)
predsgseq = utilities.collectPreds(
    [
        ffn3, ffn5,
        ffn10, cnn3,
        cnn5, cnn10,
        cnnlin, rf
    ],
    [
        gseq.xgseqffn, gseq.xgseqffn,
        gseq.xgseqffn, gseq.xgseqcnn,
        gseq.xgseqcnn, gseq.xgseqcnn,
        gseq.xgseqcnn, gseq.xgseqrf
    ]
)
# correct predictions of Linn et al.
predsgseq.yscore[-2][:, 1] = np.abs(predsgseq.yscore[-2][:, 1])
for n in range(len(predsgseq.yscore[-2])):
    under = predsgseq.yscore[-2][n, 0] + predsgseq.yscore[-2][n, 1]
    predsgseq.yscore[-2][n, 0] = predsgseq.yscore[-2][n, 0] / (under)
    predsgseq.yscore[-2][n, 1] = predsgseq.yscore[-2][n, 1] / (under)
#
for objfun in [utilities.brierScore, accuracy_score, f1_score, precision_score, recall_score]:
    if 'brier' in str(objfun):
        utilities.computeScore(objfun, loadguideseq.target, predsgseq.yscore)
    else:
        utilities.computeScore(objfun, loadguideseq.target, predsgseq.ypred)
#
utilities.printTopPreds(
    cnn3,
    xtestcnn,
    gseq.ygseqdf,
    loadguideseq.target_names,
    imgrows
)
#
# Last card of module offtargetmodelsexperiments8x23.
#

